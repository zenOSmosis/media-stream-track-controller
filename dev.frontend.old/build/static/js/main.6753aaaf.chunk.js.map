{"version":3,"sources":["../../src/index.js","../../src/_base/_MediaStreamTrackControllerBase.js","../../src/utils/index.js","components/AudioLevelMeter/AudioLevelMeter.module.css","../../src/utils/constraints.js","../../src/MediaStreamTrackControllerFactory.js","../../src/utils/getAudioContext.js","../../src/_base/_CommonControllerAndFactoryBase.js","../../src/audio/AudioMediaStreamTrackController.js","../../src/video/VideoMediaStreamTrackController.js","../../src/utils/captureMediaDevice.js","../../src/utils/captureScreen.js","../../src/utils/fetchMediaDevices.js","../../src/utils/getMatchedMediaDevice.js","../../src/utils/stopMediaStream.js","../../src/utils/getMediaStreamTrackControllerInstances.js","../../src/debug/index.js","../../src/debug/createTestAudioMediaStream.js","../../src/debug/createTestVideoMediaStream.js","../../src/audio/AudioMediaStreamTrackLevelMonitor/index.js","../../src/audio/AudioMediaStreamTrackLevelMonitor/AudioMediaStreamTrackLevelMonitorProxy.js","../../src/audio/AudioMediaStreamTrackLevelMonitor/_AudioMediaStreamTrackLevelMonitor.js","components/AudioLevelMeter/AudioLevelMeter.jsx","components/AudioLevelMeter/AudioMediaStreamTrackLevelMeter.jsx","components/AudioLevelMeter/index.jsx","App.js","reportWebVitals.js","index.js"],"names":["require","EVT_READY","EVT_UPDATED","EVT_DESTROYED","AudioMediaStreamTrackController","VideoMediaStreamTrackController","MediaStreamTrackControllerFactory","utils","debug","AudioMediaStreamTrackLevelMonitor","EVT_AVERAGE_AUDIO_LEVEL_CHANGED","EVT_AUDIO_LEVEL_TICK","EVT_AUDIO_ERROR","EVT_AUDIO_ERROR_RECOVERED","module","exports","MediaStreamTrackControllerEvents","AudioMediaStreamTrackLevelMonitorEvents","CommonBase","_instances","MediaStreamTrackControllerBase","inputMediaStreamTrack","options","MediaStreamTrack","TypeError","_uuid","_inputMediaStreamTrack","_outputMediaStreamTrack","_isTrackEnded","setTimeout","_handleTrackEnded","destroy","addEventListener","once","removeEventListener","this","kind","getSettings","inputSettings","getInputSettings","deviceId","getInputDeviceId","mediaDeviceInfoList","getMatchedMediaDevice","partialMediaDeviceInfo","getPartialMediaDeviceInfo","getKind","stop","dispatchEvent","Event","Object","values","constraints","captureMediaDevice","captureScreen","getIsScreenCaptureSupported","fetchMediaDevices","getNewAudioContext","getSharedAudioContext","untilAudioContextResumed","stopMediaStream","getMediaStreamTrackControllerInstances","PhantomCore","mergeConstraints","defaultConstraints","userConstraints","mergeOptions","createNormalizedConstraintsOfKind","undefined","prevUserConstraints","createAudioConstraints","DEFAULT_AUDIO_CONSTRAINTS","audio","echoCancellation","noiseSuppression","autoGainControl","sampleRate","sampleSize","createVideoConstraints","DEFAULT_VIDEO_CONSTRAINTS","video","getSpecificDeviceIdCaptureConstraints","deviceType","AUDIO_DEVICE_TYPE","VIDEO_DEVICE_TYPE","OVERRIDE_CONSTRAINTS","exact","createScreenCaptureConstraints","DEFAULT_CONSTRAINTS","cursor","getSpecificDeviceCaptureConstraints","mediaDeviceInfo","MediaDeviceInfo","console","warn","MediaStreamTrackController","debounce","_factoryInstances","MediaStreamControllerFactory","inputMediaStream","factoryOptions","MediaStream","DEFAULT_FACTORY_OPTIONS","isReady","_trackControllers","createTrackControllersFromMediaStream","lenControllers","length","lenInitControllers","controller","onceReady","then","handleTrackUpdated","_syncTrackControllersMuteState","emit","on","filter","test","is","off","_outputMediaStream","map","getOutputMediaStreamTrack","every","getIsMuted","_isMuted","some","isMuted","forEach","setIsMuted","getTrackControllers","Promise","all","controllers","getTracks","track","push","AudioContext","window","webkitAudioContext","sharedAudioCtx","audioCtx","state","resume","CommonControllerAndFactoryBase","args","DEFAULT_OPTIONS","_audioCtx","_unmutedGain","_src","createMediaStreamSource","_dst","createMediaStreamDestination","_gainNode","createGain","connect","stream","setGain","gain","isSetUnmutedGain","_isReady","Error","value","navigator","mediaDevices","getUserMedia","mediaStream","ReferenceError","getMediaDeviceTrackControllers","captureSpecificMediaDevice","uncaptureSpecificMediaDevice","getIsMediaDeviceBeingCaptured","getIsMediaDeviceCaptureSupported","getDisplayMedia","cache","lastIsAggressive","lastMediaDevices","isAggressive","enumerateDevices","fetchDevices","devices","label","tempMediaStream","cacheDiffMediaDevices","prevMediaDevices","nextMediaDevices","next","device","Boolean","find","predicate","filterInputMediaDevices","includes","filterOutputMediaDevices","filterAudioInputDevices","filterVideoInputDevices","filterAudioOutputDevices","filterVideoOutputDevices","matchedDevice","removeTrack","BaseTrackController","createTestAudioMediaStream","createTestVideoMediaStream","logger","duration","pulseHz","lfoHz","osc","createOscillator","type","frequency","setValueAtTime","currentTime","amp","lfo","streamOutput","start","log","close","canvas","document","createElement","body","appendChild","captureStream","removeChild","AudioMediaStreamTrackLevelMonitorProxy","_monitorInstances","_proxyCounts","mediaStreamTrack","validateAudioTrack","_mediaStreamTrack","addProxyInstance","proxy","getMediaStreamTrack","monitor","id","proxies","proxyEvents","proxyHandlers","proxyEvent","data","clone","_silenceErrorDetectionTimeout","_silenceAudioError","_prevAudioLevel","_pollingStartTime","_analyser","_stream","_source","_handleFocus","_initAudioLevelPolling","clearTimeout","rms","log2Rms","_isDestroyed","getTime","audioContext","getIsDestroyed","_isAudioContextStarted","createAnalyser","fftSize","smoothingTimeConstant","disconnect","samples","Uint8Array","frequencyBinCount","audioLevelDidChange","pollingStartTime","_handlePollTick","analyser","getByteFrequencyData","rootMeanSquare","Math","log2","_emitAudioLevelTick","newAudioLevel","ceil","sumSq","reduce","sample","sqrt","Date","audioLevel","_audioLevel","silenceDidEnd","silenceDidStart","error","message","audioError","AudioLevelMeter","className","percent","percents","rest","renderedLevels","useMemo","level","classNames","styles","idx","style","clipPath","WebkitClipPath","AudioMediaStreamTrackLevelMeter","useState","setPercent","useEffect","mediaStreamMonitor","MediaElement","trackController","inputMediaDevices","videoEl","setVideoEl","a","srcObject","muted","play","scrollIntoView","inputDeviceId","matchedInputMediaDevice","match","getInputMediaDeviceInfoFromList","JSON","parse","stringify","computedTrackControllers","isCaptured","display","border","backgroundColor","color","textAlign","entries","key","playsInline","ref","controls","width","height","getTrackKind","onClick","mute","unmute","disabled","App","collection","PhantomCollection","mediaStreamTrackControllerFactories","setMediaStreamTrackControllerFactories","setMediaDevices","setInputMediaDevices","outputMediaDevices","setOutputMediaDevices","registerControllerFactory","useCallback","controllerFactory","outputMediaStream","getOutputMediaStream","outputMediaStreamTracks","prev","handleUpdate","factoryInstances","getFactoryInstances","createPulsatingAudio","margin","alert","name","cb","title","overflow","padding","float","borderTop","factory","getTitle","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"qGAAA,MAIIA,EAAQ,IAHVC,EADF,EACEA,UACAC,EAFF,EAEEA,YACAC,EAHF,EAGEA,cAEIC,EAAkCJ,EAAQ,IAC1CK,EAAkCL,EAAQ,IAC1CM,EAAoCN,EAAQ,IAC5CO,EAAQP,EAAQ,IAChBQ,EAAQR,EAAQ,IAChBS,EAAoCT,EAAQ,IAEhDU,EAIED,EAJFC,gCACAC,EAGEF,EAHFE,qBACAC,EAEEH,EAFFG,gBACAC,EACEJ,EADFI,0BAGFC,EAAOC,QAAU,CACfX,kCACAC,kCACAW,iCAAkC,CAChCf,YACAC,cACAC,iBAEFG,oCACAC,QACAC,QACAC,oCACAQ,wCAAyC,CACvCd,gBACAO,kCACAC,uBACAC,kBACAC,+B,gGCnCEK,EAAalB,EAAQ,IACnBE,EAA+BgB,EAA/BhB,YAAaC,EAAkBe,EAAlBf,cAGfgB,EAAa,GAObC,E,2CAcJ,WAAYC,GAAqC,MAAdC,EAAc,uDAAJ,GAC3C,GAD+C,YACzCD,aAAiCE,kBACrC,MAAM,IAAIC,UACR,yDAH2C,OAO/C,cAAMF,GAENH,EAAW,EAAKM,OAAhB,KAEA,EAAKC,uBAAyBL,EAI9B,EAAKM,wBAA0BN,EAE/B,EAAKO,eAAgB,EAMnBC,YAAW,WACT,IAAMC,EAAoB,WAGnB,EAAKF,gBACR,EAAKA,eAAgB,EAErB,EAAKG,YAIT,EAAKL,uBAAuBM,iBAC1B,QACAF,GAEF,EAAKH,wBAAwBK,iBAC3B,QACAF,GAGF,EAAKG,KAAK9B,GAAe,WACvB,EAAKuB,uBAAuBQ,oBAC1B,QACAJ,GAEF,EAAKH,wBAAwBO,oBAC3B,QACAJ,SAlDuC,E,iCAiEjD,WACE,OAAOK,KAAKT,uBAAuBU,O,uCAMrC,WACE,OAAOD,KAAKR,0B,4BAQd,WACE,OAAOQ,KAAKR,0B,0BAMd,WACE,OAAOQ,KAAKR,wBAAwBS,O,8BAQtC,WACE,OAAOD,KAAKT,uBAAuBW,gB,+BASrC,WACE,OAAOF,KAAKR,wBAAwBU,gB,8BAWtC,WACE,IAAMC,EAAgBH,KAAKI,mBAE3B,GAAID,EACF,OAAOA,EAAcE,W,uCAYzB,WACE,MAAO,CACLA,SAAUL,KAAKM,sB,6CAkBnB,SAAgCC,GAO9B,IACQC,EADM3C,EAAQ,IACd2C,sBAEFC,EAAyBT,KAAKU,4BAEpC,OAAOF,EAAsB,GAAD,OACvBR,KAAKW,UADkB,SAE1BF,EACAF,K,gDAOJ,4EAEEP,KAAKT,uBAAuBqB,OAC5BZ,KAAKR,wBAAwBoB,OAI7BZ,KAAKR,wBAAwBqB,cAAc,IAAIC,MAAM,iBAE9C9B,EAAWgB,KAAKV,OAEvB,4CAXF,gD,4GAzLA,WACE,OAAOyB,OAAOC,OAAOhC,O,GAPoBD,GA8M7CJ,EAAOC,QAAUK,EACjBN,EAAOC,QAAQb,YAAcA,EAC7BY,EAAOC,QAAQZ,cAAgBA,G,qBC3N/B,IAAMiD,EAAcpD,EAAQ,IACtBqD,EAAqBrD,EAAQ,IAC7BsD,EAAgBtD,EAAQ,IACtBuD,EAAgCD,EAAhCC,4BACFC,EAAoBxD,EAAQ,IAClC,EAIIA,EAAQ,IAHVyD,EADF,EACEA,mBACAC,EAFF,EAEEA,sBACAC,EAHF,EAGEA,yBAEIhB,EAAwB3C,EAAQ,IAChC4D,EAAkB5D,EAAQ,IAC1B6D,EAAyC7D,EAAQ,IAEvDc,EAAOC,QAAU,CACfqC,cACAC,qBACAC,gBACAC,8BACAC,oBACAC,qBACAC,wBACAC,2BACAhB,wBACAiB,kBACAC,2C,mBCxBF/C,EAAOC,QAAU,CAAC,OAAS,gCAAgC,kBAAkB,yCAAyC,MAAQ,+BAA+B,kBAAkB,2C,wCCEzK+C,EAAc9D,EAAQ,GAU5B,SAAS+D,EAAiBC,EAAoBC,GAC5C,OAAOH,EAAYI,aAAaF,EAAoBC,GAatD,SAASE,EAAkC/B,GAA4B,IAAtB6B,EAAsB,uDAAJ,GACjE,GAAa,UAAT7B,GAA6B,UAATA,EACtB,MAAM,IAAIZ,UAAU,sCAItB,GAA+B,mBAApByC,EACT,YACG7B,EAAO6B,GASZ,GAJwB,OAApBA,QAAgDG,IAApBH,IAC9BA,EAAkB,SAGUG,IAA1BH,EAAgB7B,GAAqB,CAEvC,IAAMiC,EAAsB,EAAH,GAAQJ,GAEjCA,EAAkB,EAAH,GACZ7B,EAAOiC,aAE+BD,IAAhCH,EAAgB7B,GAAMA,KAG/B6B,EAAgB7B,GAAhB,KAA6B6B,EAAgB7B,GAAMA,KAGrD,OAAO6B,EAOT,SAASK,IAA6C,IAAtBL,EAAsB,uDAAJ,GAC1CM,EAA4B,CAChCC,MAAO,CACLC,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,EACjBC,WAAY,KACZC,WAAY,KAIhB,OAAOd,EACLQ,EACAJ,EAAkC,QAASF,IAQ/C,SAASa,IAA6C,IAAtBb,EAAsB,uDAAJ,GAC1Cc,EAA4B,CAEhCC,MAAO,IAGT,OAAOjB,EACLgB,EACAZ,EAAkC,QAASF,IA+C/C,SAASgB,EACPzC,EACA0C,GAEA,MADAjB,EACA,uDADkB,GAEZkB,EAAoB,QACpBC,EAAoB,QAE1B,GAAIF,IAAeC,GAAqBD,IAAeE,EACrD,MAAM,IAAI5D,UAAU,qCAGtB,IAAM6D,GAAoB,OACvBH,EAAa,CACZ1C,SAAU,CACR8C,MAAO9C,KAHa,IAQvB0C,IAAeC,EACZC,EACAD,GAAoB,GAVA,GAoB1B,OAAoC,KANpClB,EAAkBE,EAChBe,EACAjB,IAIkBiB,GACX,GAGFnB,EAAiBE,EAAiBoB,GA4B3CvE,EAAOC,QAAU,CACfgD,mBACAI,oCACAG,yBACAQ,yBACAS,+BA5GF,WAA8D,IAAtBtB,EAAsB,uDAAJ,GA2BxD,OA1BAuB,oBAAsB,EAAH,KAWdlB,EAAuBL,GAAmBA,EAAgBO,QAK1DM,EACDf,EACE,CACE0B,OAAQ,UAEVxB,GAAmBA,EAAgBe,SAKlCjB,EAAiByB,oBAAqBvB,IAkF7CgB,wCACAS,oCAxBF,SACEC,GAEA,IADA1B,EACA,uDADkB,GAElB,KAAM0B,aAA2BC,iBAG/B,MAFAC,QAAQC,YAAYH,GAEd,IAAInE,UAAU,mDAGtB,OAAOyD,EACLU,EAAgBnD,SACS,eAAzBmD,EAAgBvD,KAAwB,QAAU,QAClD6B,M,sGCxME/C,EAAalB,EAAQ,IACnBC,EAA0CiB,EAA1CjB,UAAWC,EAA+BgB,EAA/BhB,YAAaC,EAAkBe,EAAlBf,cAC1B4F,EAA6B/F,EAAQ,IACrCI,EAAkCJ,EAAQ,IAC1CK,EAAkCL,EAAQ,IAC1CgG,EAAWhG,EAAQ,IAGnBiG,EAAoB,GAMpBC,E,2CA0DJ,WAAYC,GAAuC,QAArBC,EAAqB,uDAAJ,GAC7C,GADiD,YAC3CD,aAA4BE,aAChC,MAAM,IAAI7E,UAAU,+CAGtB,IAAM8E,EAA0B,CAE9BC,SAAS,GAPsC,OAUjD,cAAMrF,EAAWgD,aAAaoC,EAAyBF,IAEvDH,EAAkB,EAAKxE,OAAvB,KAEA,EAAK+E,kBACHN,EAA6BO,sCAC3BN,EACAC,GAIJ,WAEE,IAFK,EAEDM,EAAiB,EAAKF,kBAAkBG,OAExCC,EAAqB,EAJpB,IAMoB,EAAKJ,mBANzB,yBAMMK,EANN,QAOHA,EAAWC,YAAYC,MAAK,aACxBH,IAEyBF,GACzB,gDAQJ,IAAMM,EAAqBhB,GACzB,WAEE,EAAKiB,iCAGL,EAAKC,KAAKhH,KAEZ,GAEA,GAGF2G,EAAWM,GAAGjH,EAAa8G,GAE3BH,EAAW5E,KAAK9B,GAAe,WAE7B,EAAKqG,kBAAoB,EAAKA,kBAAkBY,QAC9C,SAAAC,GAAI,OAAKnE,OAAOoE,GAAGD,EAAMR,MAI3B,EAAKK,KAAKhH,GAEV2G,EAAWU,IAAIrH,EAAa8G,GAOL,MAJrBN,GAKA,EAAK3E,cA7CX,2BAAiD,IAN5C,8BAyDA,EAAKyE,kBAAkBG,QAC1B,EAAK5E,UA1DT,GAgEA,EAAKyF,mBAAqB,IAAInB,YAAJ,EACrB,EAAKG,kBAAkBiB,KAAI,SAAAZ,GAAU,OACtCA,EAAWa,iCAvFkC,E,wDAoGnD,WACiCvF,KAAKqE,kBAAkBmB,OAAM,SAAAd,GAAU,OACpEA,EAAWe,gBAIXzF,KAAK0F,UAAW,EAEkB1F,KAAKqE,kBAAkBsB,MACvD,SAAAjB,GAAU,OAAKA,EAAWe,kBAI1BzF,KAAK0F,UAAW,K,wBAWtB,SAAWE,GAKT,OAJA5F,KAAKqE,kBAAkBwB,SAAQ,SAAAnB,GAAU,OACvCA,EAAWoB,WAAWF,MAGxB,iD,iCAMF,WACE,OAAO5F,KAAKqE,oB,sCAMd,WACE,OAAOrE,KAAK+F,sBAAsBd,QAChC,SAAAP,GAAU,OAAIA,aAAsBzG,O,sCAOxC,WACE,OAAO+B,KAAK+F,sBAAsBd,QAChC,SAAAP,GAAU,OAAIA,aAAsBxG,O,kCAcxC,WACE,OAAO8B,KAAKqF,qB,+BAWd,WACE,OAAOrF,KAAK+F,sBAAsBT,KAAI,SAAAZ,GAAU,OAC9CA,EAAWpE,wB,gDAOf,0FACSwD,EAAkB9D,KAAKV,OADhC,SAIQ0G,QAAQC,IACZjG,KAAKqE,kBAAkBiB,KAAI,SAAAZ,GAAU,OAAIA,EAAW9E,cALxD,OAQE,4CARF,gD,4GAhPA,WACE,OAAOgE,EAA2BlC,2C,iCAMpC,WACE,OAAOX,OAAOC,OAAO8C,K,mDAYvB,SACEE,GAEA,MADAC,EACA,uDADiB,GAEXiC,EAAc,GADpB,IAGoBlC,EAAiBmC,aAHrC,IAGA,2BAAkD,KAAvCC,EAAuC,QAChD,OAAQA,EAAMnG,MACZ,IAAK,QACHiG,EAAYG,KACV,IAAIpI,EAAgCmI,EAAOnC,IAE7C,MAEF,IAAK,QACHiC,EAAYG,KACV,IAAInI,EAAgCkI,EAAOnC,IAE7C,MAEF,QACE,MAAM,IAAI5E,UAAJ,8BAAqC+G,EAAMnG,SAlBvD,8BAsBA,OAAOiG,M,GAnDgCnH,GAkQ3CJ,EAAOC,QAAUmF,EACjBpF,EAAOC,QAAQd,UAAYA,EAC3Ba,EAAOC,QAAQb,YAAcA,EAC7BY,EAAOC,QAAQZ,cAAgBA,G,kCC9QzBsD,EAAqB,WACzB,IAAMgF,EAAeC,OAAOD,cAAgBC,OAAOC,mBAGnD,OAFiBF,EAAe,IAAIA,EAAiB,MAWjD/E,EAAyB,WAE7B,IAAMkF,EAAiBnF,IAQvB,OAAO,kBAAMmF,GAVgB,GAoBzBjF,EAAwB,2BAAG,kGAAOkF,EAAP,+BAAkB,QAE/CA,EAAWnF,KAKwB,YAAnBmF,EAASC,MAPI,uBAa7BjD,QAAQrF,MAAM,kCAbe,SAevBqI,EAASE,SAfc,OAiB7BlD,QAAQrF,MAAM,yBAjBe,2CAAH,qDAqB9BM,EAAOC,QAAQ0C,mBAAqBA,EACpC3C,EAAOC,QAAQ2C,sBAAwBA,EACvC5C,EAAOC,QAAQ4C,yBAA2BA,G,8DC7DpCG,EAAc9D,EAAQ,GACpBE,EAA+B4D,EAA/B5D,YAAaC,EAAkB2D,EAAlB3D,cAMf6I,E,2CACJ,aAAqB,2CAANC,EAAM,yBAANA,EAAM,uBACnB,+BAASA,KAEJpB,UAAW,EAHG,E,oCAUrB,SAAWE,GACT5F,KAAK0F,SAAWE,EAEhB5F,KAAK+E,KAAKhH,K,wBAMZ,WACE,OAAOiC,KAAK0F,W,kBAMd,WACE1F,KAAK8F,YAAW,K,oBAMlB,WACE9F,KAAK8F,YAAW,K,wBAQlB,WACE9F,KAAK8F,YAAY9F,KAAK0F,Y,6CAQxB,qGACS1F,KAAKJ,WADd,gD,2DApD2C+B,GAyD7ChD,EAAOC,QAAUiI,EACjBlI,EAAOC,QAAQb,YAAcA,EAC7BY,EAAOC,QAAQZ,cAAgBA,G,2FClEzB2D,EAAc9D,EAAQ,GACtBoB,EAAiCpB,EAAQ,IACvCE,EAA+BkB,EAA/BlB,YAAaC,EAAkBiB,EAAlBjB,cACbuD,EAA0B1D,EAAQ,IAAlC0D,sBAUFtD,E,2CAKJ,WAAYiB,GAAqC,QAAdC,EAAc,uDAAJ,GAC3C,GAD+C,UACZ,UAA/BD,EAAsBe,KACxB,MAAM,IAAIZ,UAAU,8CAGtB,IAAM0H,EAAkB,CACtB3C,SAAS,GANoC,OAS/C,cACElF,EACAyC,EAAYI,aAAagF,EAAiB5H,KAIvC6H,UAAYzF,IAGjB,EAAK0F,aAAe,EAEpB,UAAC,mFACC,EAAKC,KAAO,EAAKF,UAAUG,wBACzB,IAAIjD,YAAY,CAAChF,KAGnB,EAAKkI,KAAO,EAAKJ,UAAUK,+BAC3B,EAAKC,UAAY,EAAKN,UAAUO,aAEhC,EAAKL,KAAKM,QAAQ,EAAKF,WACvB,EAAKA,UAAUE,QAAQ,EAAKJ,MAE5B,EAAK/B,mBAAqB,EAAK+B,KAAKK,OACpC,EAAKjI,wBAA0B,EAAK6F,mBAAmBc,YAAY,GAZpE,gGAAD,GApB+C,E,oCAyCjD,SAAWP,GACT5F,KAAK0H,QAAQ9B,EAAU,EAAI5F,KAAKiH,cAAc,GAE9C,8CAAiBrB,K,qBAQnB,SAAQ+B,GAA+B,IAAzBC,IAAyB,yDAKrC,GAJIA,IACF5H,KAAKiH,aAAeU,IAGjB3H,KAAK6H,SACR,MAAM,IAAIC,MAAM,gDAGd9H,KAAKsH,YACPtH,KAAKsH,UAAUK,KAAKI,MAAQJ,GAG9B3H,KAAK+E,KAAKhH,K,qBAQZ,WACE,IAAKiC,KAAK6H,SACR,MAAM,IAAIC,MAAM,gDAGlB,OAAO9H,KAAKsH,WAAatH,KAAKsH,UAAUK,MAAQ3H,KAAKsH,UAAUK,KAAKI,U,GAnF1B9I,GAuF9CN,EAAOC,QAAUX,EACjBU,EAAOC,QAAQb,YAAcA,EAC7BY,EAAOC,QAAQZ,cAAgBA,G,gECtGzBiB,EAAiCpB,EAAQ,IACvCE,EAA+BkB,EAA/BlB,YAAaC,EAAkBiB,EAAlBjB,cAKfE,E,2CAKJ,WAAYgB,GAAqC,IAAdC,EAAc,uDAAJ,GAC3C,GAD+C,UACZ,UAA/BD,EAAsBe,KACxB,MAAM,IAAIZ,UAAU,8CAFyB,mBAKzCH,EAAuBC,G,oCAG/B,SAAWyG,GACTlC,QAAQC,KAAK,iDAGb,8CAAiBiC,O,GAjByB3G,GAqB9CN,EAAOC,QAAUV,EACjBS,EAAOC,QAAQb,YAAcA,EAC7BY,EAAOC,QAAQZ,cAAgBA,G,wGC7BzBiB,EAAiCpB,EAAQ,IACzCM,EAAoCN,EAAQ,IAElD,EAIIA,EAAQ,IAHV+D,EADF,EACEA,iBACA2B,EAFF,EAEEA,oCACApB,EAHF,EAGEA,uB,SAUajB,I,+DAAf,2GAAkCD,EAAlC,+BAAgD,GAAIgD,EAApD,+BAAqE,GAC7DZ,EADR,OAEOlB,EAAuBlB,GAAeA,EAAYoB,QAFzD,IAMIQ,OAAO,IANX,SAS4BmF,UAAUC,aAAaC,aAC/CtG,EAAiByB,EAAqBpC,IAV1C,cASQkH,EATR,yBAaS,IAAIhK,EAAkCgK,EAAalE,IAb5D,4C,sDAyBA,WACET,GADF,0FAEEvC,EAFF,+BAEgB,GACdgD,EAHF,+BAGmB,GAHnB,kBAKS/C,EACLqC,EAAoCC,EAAiB,QAASvC,GAC9DgD,IAPJ,4C,sDAoBA,WAA4CT,GAA5C,wEACUnD,EAAamD,EAAbnD,SADV,sBAIU,IAAI+H,eAAe,kDAJ7B,gCAQSpC,QAAQC,IACbhH,EAA+ByC,yCAC5BuD,QAAO,SAAAP,GAAU,OAAIA,EAAWpE,qBAAuBD,KACvDiF,KAAI,SAAAZ,GAAU,OAAIA,EAAW9E,eAXpC,4C,sBAqBA,SAASyI,EAA+B7E,GACtC,IAAQnD,EAAamD,EAAbnD,SAER,IAAKA,EACH,MAAM,IAAI+H,eAAe,kDAG3B,OAAOnJ,EAA+ByC,yCAAyCuD,QAC7E,SAAAP,GAAU,OAAIA,EAAWpE,qBAAuBD,KA4BpD1B,EAAOC,QAAUsC,EACjBvC,EAAOC,QAAQ0J,2B,4CACf3J,EAAOC,QAAQ2J,6B,4CACf5J,EAAOC,QAAQyJ,+BAAiCA,EAChD1J,EAAOC,QAAQ4J,8BAtBf,SAAuChF,GACrC,OAAO6E,EAA+B7E,GAAiBgB,OAAS,GAsBlE7F,EAAOC,QAAQ6J,iCAbf,WACE,OACET,WACAA,UAAUC,cACqC,oBAAxCD,UAAUC,aAAaC,e,mCClH5B/J,EAAoCN,EAAQ,IAE1CuF,EAAmCvF,EAAQ,IAA3CuF,+B,gCAOR,yGAA6BnC,EAA7B,+BAA2C,GAAIgD,EAA/C,+BAAgE,GAAhE,SAC4B+D,UAAUC,aAAaS,gBAC/CtF,EAA+BnC,IAFnC,cACQkH,EADR,yBAKS,IAAIhK,EAAkCgK,EAAalE,IAL5D,4C,sBAmBAtF,EAAOC,Q,2CACPD,EAAOC,QAAQwC,4BATf,WACE,OACE4G,WACAA,UAAUC,cACwC,oBAA3CD,UAAUC,aAAaS,kB,0CCb5BrH,EAAqB,WACzB,IAAMsH,EAAQ,CACZC,iBAAkB,KAClBC,iBAAkB,IAGpB,iBAAO,uGAAOC,IAAP,iCACAd,UAAUC,cAAiBD,UAAUC,aAAac,iBADlD,uBAEHrF,QAAQC,KAAK,qCAFV,kBAGI,IAHJ,cAMCqF,EAAe,kBAAMhB,UAAUC,aAAac,oBAN7C,SAQeC,IARf,UAQDC,EARC,QAWDH,IAAgBG,EAAQtD,MAAK,qBAAGuD,MAAmB1E,UAXlD,kCAa2BwD,UAAUC,aAAaC,aAAa,CAChE7F,OAAO,IAdN,eAaG8G,EAbH,iBAkBaH,IAlBb,QAkBHC,EAlBG,OAqBHE,EAAgBhD,YAAYN,SAAQ,SAAAO,GAAK,OAAIA,EAAMxF,UArBhD,eA0BD+H,EAAMC,mBAAqBE,EAC7BG,EAAUG,EAAsBT,EAAME,iBAAkBI,IAKxDN,EAAMC,iBAAmBE,EAGzBH,EAAME,iBAAmB,IAG3BF,EAAME,iBAAN,EAA6BI,GAtCxB,kBAwCEA,GAxCF,4CANkB,GAuDrBG,EAAwB,SAACC,EAAkBC,GAS/C,IAAMC,EAAOF,EAAiBpE,QAAO,SAAAuE,GAAM,OACzCC,QACEH,EAAiBI,MAAK,SAAAC,GAKpB,OAHEA,EAAU1J,OAASuJ,EAAOvJ,MAC1B0J,EAAUtJ,WAAamJ,EAAOnJ,gBAsBtC,OAdAiJ,EAAiBzD,SAAQ,SAAA2D,GACJC,QACjBJ,EAAiBK,MACf,SAAAC,GAAS,OACPA,EAAU1J,OAASuJ,EAAOvJ,MAC1B0J,EAAUtJ,WAAamJ,EAAOnJ,cAKlCkJ,EAAKlD,KAAKmD,MAIPD,GAUHK,EAA0B,SAAArJ,GAC9B,OAAOA,EAAoB0E,QAAO,SAAAuE,GAAM,OAAIA,EAAOvJ,KAAK4J,SAAS,aAoC7DC,EAA2B,SAAAvJ,GAC/B,OAAOA,EAAoB0E,QAAO,SAAAuE,GAAM,OAAIA,EAAOvJ,KAAK4J,SAAS,cA6BnElL,EAAOC,QAAUyC,EAEjB1C,EAAOC,QAAQwK,sBAAwBA,EAEvCzK,EAAOC,QAAQgL,wBAA0BA,EACzCjL,EAAOC,QAAQmL,wBA7DiB,SAAAxJ,GAC9B,OAAOqJ,EAAwBrJ,GAAqB0E,QAAO,SAAAuE,GAAM,OAC/DA,EAAOvJ,KAAK4J,SAAS,aA4DzBlL,EAAOC,QAAQoL,wBAjDiB,SAAAzJ,GAC9B,OAAOqJ,EAAwBrJ,GAAqB0E,QAAO,SAAAuE,GAAM,OAC/DA,EAAOvJ,KAAK4J,SAAS,aAiDzBlL,EAAOC,QAAQkL,yBAA2BA,EAC1CnL,EAAOC,QAAQqL,yBA5BkB,SAAA1J,GAC/B,OAAOuJ,EAAyBvJ,GAAqB0E,QAAO,SAAAuE,GAAM,OAChEA,EAAOvJ,KAAK4J,SAAS,aA2BzBlL,EAAOC,QAAQsL,yBAhBkB,SAAA3J,GAC/B,OAAOuJ,EAAyBvJ,GAAqB0E,QAAO,SAAAuE,GAAM,OAChEA,EAAOvJ,KAAK4J,SAAS,c,cCpHzBlL,EAAOC,QA/CuB,SAACqB,EAAMuD,EAAiBjD,GAQpD,IAPwB,CACtB,aACA,aACA,cACA,eAGmBsJ,SAAS5J,GAC5B,MAAM,IAAImI,eAAJ,wBAAoCnI,EAApC,MAIR,GAAIuD,EAAgBnD,SAAU,CAC5B,IAAM8J,EAAgB5J,EAAoBmJ,MACxC,SAAAF,GAAM,OACJvJ,IAASuJ,EAAOvJ,MAAQuD,EAAgBnD,WAAamJ,EAAOnJ,YAGhE,GAAI8J,EACF,OAAOA,EAQX,GAAI3G,EAAgB0F,MAAO,CAEzB,IAAMiB,EAAgB5J,EAAoBmJ,MACxC,SAAAF,GAAM,OAAIvJ,IAASuJ,EAAOvJ,MAAQuD,EAAgB0F,QAAUM,EAAON,SAGrE,GAAIiB,EACF,OAAOA,EAOX,OAAO,O,cCvBTxL,EAAOC,QAxBP,SAAyBuJ,GACvBA,EAAYhC,YAAYN,SAAQ,SAAAO,GAC9BA,EAAMxF,OAkBNuH,EAAYiC,YAAYhE,Q,gBC3B5B,IAAMiE,EAAsBxM,EAAQ,IASpCc,EAAOC,QAJP,WACE,OAAOyL,EAAoB3I,2C,gBCN7B,IAAM4I,EAA6BzM,EAAQ,IACrC0M,EAA6B1M,EAAQ,IAE3Cc,EAAOC,QAAU,CACf0L,6BACAC,+B,gBCLF,MAAgD1M,EAAQ,IAAhDyD,EAAR,EAAQA,mBAAoBG,EAA5B,EAA4BA,gBACpB+I,EAAW3M,EAAQ,GAAnB2M,OAkDR7L,EAAOC,QAxCP,WAAkD,IAAd6L,EAAc,uDAAH,EACvCC,EAAU,IACVC,EAAQ,GAERjE,EAAWpF,IAEbsJ,EAAMlE,EAASmE,mBACnBD,EAAIE,KAAO,OACXF,EAAIG,UAAUC,eAAeN,EAAShE,EAASuE,aAE/C,IAAIC,EAAMxE,EAASa,aACnB2D,EAAIvD,KAAKI,MAAQ,KACjBmD,EAAIvD,KAAKqD,eAAe,EAAGtE,EAASuE,aAEpC,IAAIE,EAAMzE,EAASmE,mBACnBM,EAAIL,KAAO,SACXK,EAAIJ,UAAUC,eAAeL,EAAOjE,EAASuE,aAE7C,IAAMG,EAAe1E,EAASW,+BAE9B8D,EAAI3D,QAAQ0D,EAAIvD,MAChBiD,EAAIpD,QAAQ0D,GAAK1D,QAAQ4D,GACzBD,EAAIE,QACJT,EAAIS,QACJT,EAAIhK,KAAK8F,EAASuE,YAAcR,GAEhC,IAAMtC,EAAciD,EAAa3D,OAWjC,OARA/H,YAAW,WACT+B,EAAgB0G,GAEhBqC,EAAOc,IAAI,wBAEX5E,EAAS6E,QAAQ3G,MAAK,kBAAM4F,EAAOc,IAAI,6BAC3B,IAAXb,GAEItC,I,gBChDT,IAAQ1G,EAAoB5D,EAAQ,IAA5B4D,gBACA+I,EAAW3M,EAAQ,GAAnB2M,OA4BR7L,EAAOC,QAlBP,WAAkD,IAAd6L,EAAc,uDAAH,EACvCe,EAASC,SAASC,cAAc,UAEtCD,SAASE,KAAKC,YAAYJ,GAE1B,IAAMrD,EAAcqD,EAAOK,cAAc,IAUzC,OARAnM,YAAW,WACT+B,EAAgB0G,GAEhBsD,SAASE,KAAKG,YAAYN,GAE1BhB,EAAOc,IAAI,0BACC,IAAXb,GAEItC,I,gBC1BT,IAAM4D,EAAyClO,EAAQ,IAErDG,EAKE+N,EALF/N,cACAO,EAIEwN,EAJFxN,gCACAC,EAGEuN,EAHFvN,qBACAC,EAEEsN,EAFFtN,gBACAC,EACEqN,EADFrN,0BAGFC,EAAOC,QAAUmN,EACjBpN,EAAOC,QAAQZ,cAAgBA,EAC/BW,EAAOC,QAAQL,gCACbA,EACFI,EAAOC,QAAQJ,qBAAuBA,EACtCG,EAAOC,QAAQH,gBAAkBA,EACjCE,EAAOC,QAAQF,0BAA4BA,G,sECfrCiD,EAAc9D,EAAQ,GACpB2M,EAAW7I,EAAX6I,OACFlM,EAAoCT,EAAQ,IAEhDU,EAKED,EALFC,gCACAC,EAIEF,EAJFE,qBACAC,EAGEH,EAHFG,gBACAC,EAEEJ,EAFFI,0BACAV,EACEM,EADFN,cASIgO,EAAoB,GAOpBC,EAAe,GAUfF,E,2CAyFJ,WAAYG,GAAkB,uBAC5B5N,EAAkC6N,mBAAmBD,IAErD,gBAEKE,kBAAoBF,EAEzBH,EAAuCM,iBAAvC,MAP4B,E,6CAa9B,WACE,OAAOrM,KAAKoM,qB,+BA1Fd,SAAwBE,GACtB,IAAMJ,EAAmBI,EAAMC,sBAE3BC,EAAUR,EAAkBE,EAAiBO,IAE5CD,KACHA,EAAU,IAAIlO,EAAkC4N,IAKxCpM,KAAK9B,GAAe,WAC1B,IAAM0O,EAAUT,EAAaC,EAAiBO,IAE1CC,GACF3L,OAAOC,OAAO0L,GAAS7G,SAAQ,SAAAyG,GAAK,OAAIA,GAASA,EAAM1M,gBAI3DoM,EAAkBE,EAAiBO,IAAMD,EAEzChC,EAAOnM,MAAM,gCAAiCmO,IAG3CP,EAAaC,EAAiBO,MAK/BR,EAAaC,EAAiBO,IAHhCR,EAAaC,EAAiBO,IAAM,EAOtC,IAAME,EAAc,CAClBpO,EACAC,EACAC,EACAC,EACAV,GAII4O,EAAgB,GAEtBD,EAAY9G,SAAQ,SAAAgH,GAClBD,EAAcC,GAAc,SAAAC,GAAI,OAAIR,EAAMvH,KAAK8H,EAAYC,IAE3DN,EAAQxH,GAAG6H,EAAYD,EAAcC,OAMvCP,EAAMxM,KAAK9B,EAAX,UAA0B,+EACxB2O,EAAY9G,SAAQ,SAAAgH,GAAU,OAC5BL,EAAQpH,IAAIyH,EAAYD,EAAcC,SAItCZ,EAAaC,EAAiBO,IAG3BR,EAAaC,EAAiBO,IATX,8BAUfT,EAAkBE,EAAiBO,WACnCR,EAAaC,EAAiBO,IAXf,SAahBD,EAAQ5M,UAbQ,OAetB4K,EAAOnM,MAAM,kCAAmCmO,GAf1B,gD,GAlEuB7K,GA2GrDhD,EAAOC,QAAUmN,EACjBpN,EAAOC,QAAQL,gCACbA,EACFI,EAAOC,QAAQJ,qBAAuBA,EACtCG,EAAOC,QAAQH,gBAAkBA,EACjCE,EAAOC,QAAQF,0BAA4BA,EAC3CC,EAAOC,QAAQZ,cAAgBA,G,8EC3IzB2D,EAAc9D,EAAQ,GACpBG,EAAkB2D,EAAlB3D,cACAuD,EAA0B1D,EAAQ,IAAlC0D,sBAIFhD,EAAkC,sBAGlCC,EAAuB,mBAGvBC,EAAkB,cAGlBC,EAA4B,wBAS5BJ,E,2CAyBJ,WAAY4N,GAAkB,uBAC5B5N,EAAkC6N,mBAAmBD,IAErD,gBAKKE,kBAAoBF,EAAiBa,QAG1C,EAAKC,8BAAgC,KAGrC,EAAKC,mBAAqB,KAE1B,EAAKC,gBAAkB,EAGvB,EAAKC,kBAAoB,KAEzB,EAAKzH,UAAW,EAEhB,EAAK0H,UAAY,KACjB,EAAKC,QAAU,KACf,EAAKC,QAAU,KAGfpB,EAAiBrM,iBAAiB,SAAS,WACzC,EAAKD,aAQP,WACE,IAAM2N,EAAe,WACnB,EAAKC,0BAGPjH,OAAO1G,iBAAiB,QAAS0N,GAEjC,EAAKzN,KAAK9B,GAAe,WACvBuI,OAAOxG,oBAAoB,QAASwN,MARxC,GAgBA7N,YAAW,kBAAM,EAAK8N,2BAA0B,IArDpB,E,4DA2D9B,mFACEC,aAAazN,KAAKgN,+BAMlBhN,KAAKoM,kBAAkBxL,OAGvBZ,KAAK+E,KAAKvG,EAAsB,CAC9BkP,IAAK,EACLC,QAAS,IAZb,qG,qHAwBA,kGACEF,aAAazN,KAAKgN,gCAGdhN,KAAK4N,aAJX,wDAQE5N,KAAKmN,kBAAoBnN,KAAK6N,UAExBC,EAAevM,IAVvB,SAeQuM,EAAalH,SAfrB,WAoBM5G,KAAK+N,iBApBX,oDAwBE/N,KAAKgO,wBAAyB,EAGxB9B,EAAmBlM,KAAKoM,kBA3BhC,uBA8BU,IAAItE,MAAM,qCA9BpB,QAkCO9H,KAAKoN,YACRpN,KAAKoN,UAAYU,EAAaG,iBAC9BjO,KAAKoN,UAAUc,QAAU,KACzBlO,KAAKoN,UAAUe,sBAAwB,IAGpCnO,KAAKqN,UACRrN,KAAKqN,QAAU,IAAInJ,YAAY,CAACgI,KAG7BlM,KAAKsN,UAIRtN,KAAKsN,QAAUQ,EAAa3G,wBAAwBnH,KAAKqN,SACzDrN,KAAKsN,QAAQ9F,QAAQxH,KAAKoN,WAE1BpN,KAAKF,KAAK9B,GAAe,WACvB,EAAKsP,QAAQc,WAAW,EAAKhB,eAI3BiB,EAAU,IAAIC,WAAWtO,KAAKoN,UAAUmB,mBAG9CvO,KAAKwO,oBAAoB,GAEnBC,EAAmBzO,KAAKmN,kBAG9BnN,KAAK0O,gBAAgB,CACnBD,mBACAE,SAAU3O,KAAKoN,UACfiB,YAnEJ,iD,uFAuEA,YAA8C,QAAxBX,WAAwB,MAAlB,EAAkB,MAAfC,eAAe,MAAL,EAAK,EAC5C3N,KAAK+E,KAAKvG,EAAsB,CAC9BkP,MACAC,c,6BAUJ,YAAyD,WAAvCc,EAAuC,EAAvCA,iBAAkBE,EAAqB,EAArBA,SAAUN,EAAW,EAAXA,QAC5C,IAAIrO,KAAK4N,cAAgBa,IAAqBzO,KAAKmN,kBAAnD,CAUA,GAAInN,KAAK0F,UA7Ma,IA8MhB1F,KAAKkN,kBACPlN,KAAKkN,iBA/Ma,EAiNlBlN,KAAKwO,qBAjNa,QAmNf,CACLG,EAASC,qBAAqBP,GAC9B,IAAMX,EAAM1N,KAAK6O,eAAeR,GAC1BV,EAAUD,GAAOoB,KAAKC,KAAKrB,GAGjC1N,KAAKgP,oBAAoB,CAAEtB,MAAKC,YAGhC,IAAIsB,EAAgBH,KAAKI,KAAKvB,GAI1BsB,EAAgB,EAClBA,EAAgB,EACPA,EAAgB,KACzBA,EAAgB,IAGdjP,KAAKkN,kBAAoB+B,IAC3BjP,KAAKkN,gBAAkB+B,EAEvBjP,KAAKwO,oBAAoBS,IAM7BvP,YAAW,WACJ,EAAKqO,kBACR,EAAKW,gBAAgB,CACnBD,mBACAE,WACAN,cAGH,O,4BAOL,SAAeA,GACb,IAAMc,EAAQd,EAAQe,QAAO,SAACD,EAAOE,GAAR,OAAmBF,EAAQE,EAASA,IAAQ,GACzE,OAAOP,KAAKQ,KAAKH,EAAQd,EAAQ7J,U,qBAMnC,WACE,OAAO,IAAI+K,MAAO1B,Y,wBASpB,SAAWjI,GACLA,IAAY5F,KAAK0F,WAKrB1F,KAAKsL,IAAL,iCAAmC1F,EAAU,OAAS,UAEtD5F,KAAK0F,SAAWE,K,iCAQlB,SAAoB4J,GAClBxP,KAAKyP,YAAcD,EAEdA,EAGHxP,KAAK0P,gBAFL1P,KAAK2P,kBAKP3P,KAAK+E,KAAKxG,EAAiCiR,K,6BAM7C,WAAkB,WAChB/B,aAAazN,KAAKgN,+BAElBhN,KAAKgN,8BAAgCtN,YAAW,WAC1C,EAAKkO,cAAgB,EAAKlI,WAI9B,EAAKuH,mBAAqB,IAAInF,MAC5B,2CAIF,EAAKwD,IAAIsE,MAAM,EAAK3C,mBAAmB4C,SAGvC,EAAK9K,KAAKtG,EAAiB,EAAKwO,uBAnUE,O,2BA0UtC,WAIE,GAHAQ,aAAazN,KAAKgN,+BAGdhN,KAAKiN,mBAAoB,CAC3B,IAAM6C,EAAa9P,KAAKiN,mBAExBjN,KAAKiN,mBAAqB,KAE1BjN,KAAK+E,KAAKrG,EAA2BoR,O,iCApUzC,SAA0B5D,GACxB,KAAMA,aAA4B9M,kBAChC,MAAM,IAAIC,UACR,uDAIJ,GAA8B,UAA1B6M,EAAiBjM,KACnB,MAAM,IAAIZ,UAAU,8C,GAjBsBsC,GAkVhDhD,EAAOC,QAAUN,EACjBK,EAAOC,QAAQL,gCACbA,EACFI,EAAOC,QAAQJ,qBAAuBA,EACtCG,EAAOC,QAAQH,gBAAkBA,EACjCE,EAAOC,QAAQF,0BAA4BA,G,kMC9W5B,SAASqR,EAAT,GAKX,IAJFC,EAIC,EAJDA,UACAC,EAGC,EAHDA,QAGC,IAFDC,gBAEC,MAFU,GAEV,EADEC,EACF,kDACKC,EAAiBC,mBAAQ,WAC7B,IAAID,EAAc,YAAOF,GAQzB,MANuB,qBAAZD,GACTG,EAAe/J,KAAK4J,GAGtBG,EAAiBA,EAAe9K,KAAI,SAACgL,GAAD,OAAW,IAAMA,OAGpD,CAACL,EAASC,IAEb,OACE,6CAAKF,UAAWO,IAAWC,IAAM,OAAYR,IAAgBG,GAA7D,aACGC,EAAe9K,KAAI,SAAC2K,EAASQ,GAAV,OAClB,qBAAeT,UAAWQ,IAAO,mBAAjC,SACE,qBACER,UAAWQ,IAAM,MACjBE,MAAO,CACLC,SAAS,SAAD,OAAWV,EAAX,YACRW,eAAe,SAAD,OAAWX,EAAX,gBALVQ,SCvBlB,IAAQjS,EAAyBM,0CAAzBN,qBAEO,SAASqS,EAAT,GAGX,IAFF3E,EAEC,EAFDA,iBACGiE,EACF,oCACD,EAA8BW,mBAAS,GAAvC,mBAAOb,EAAP,KAAgBc,EAAhB,KAoBA,OAlBAC,qBAAU,WACR,GAAI9E,EAAkB,CACpB,IAAM+E,EAAqB,IAAI3S,oCAC7B4N,GASF,OANA+E,EAAmBjM,GAAGxG,GAAsB,YAAc,IAAXkP,EAAU,EAAVA,IAG7CqD,EAAWrD,MAGN,WACLuD,EAAmBrR,cAGtB,CAACsM,IAEG,cAAC6D,EAAD,aAAiBE,QAASA,GAAaE,IC9BjCJ,I,OCoRf,SAASmB,EAAT,GAA+D,IAAvCC,EAAsC,EAAtCA,gBAAiBC,EAAqB,EAArBA,kBACvC,EAA8BN,mBAAS,MAAvC,mBAAOO,EAAP,KAAgBC,EAAhB,KAEAN,qBAAU,WACR,sBAAC,4BAAAO,EAAA,0DACKJ,IAAmBE,EADxB,gCAESF,EAAgBxM,YAFzB,QAISyB,EAAQ+K,EAAgB5L,+BAG5B8L,EAAQG,UAAY,IAAItN,YAAY,CAACkC,IAErCiL,EAAQI,OAAQ,EAChBJ,EAAQK,OAGRL,EAAQM,kBAbb,0CAAD,KAiBC,CAACR,EAAiBE,IAErB,IAAMO,EAAgBvB,mBACpB,kBAAMc,EAAgB7Q,qBACtB,CAAC6Q,IAMGU,EAA0BxB,mBAAQ,WACtC,IAAMyB,EACJX,EAAgBY,gCAAgCX,GAElD,GAAIU,EAIF,OAAOE,KAAKC,MAAMD,KAAKE,UAAUJ,MAElC,CAACX,EAAiBC,IAiBrB,OAfAJ,qBAAU,WACJa,GAEFnO,QAAQ4H,IAAI,CACV6G,yBACE/T,QAAM8C,mBAAmBmH,+BACvBwJ,GAEJO,WAAYhU,QAAM8C,mBAAmBsH,8BACnCqJ,OAIL,CAACA,IAGF,sBAAKnB,MAAO,CAAE2B,QAAS,eAAgBC,OAAQ,kBAA/C,UACE,qBACE5B,MAAO,CAAE6B,gBAAiB,OAAQC,MAAO,OAAQC,UAAW,QAD9D,SAGIZ,EAGA,gCACE,4DACC9Q,OAAO2R,QAAQb,GAAyBvM,KACvC,WAAemL,GAAS,IAAD,mBAArBkC,EAAqB,KAAhB5K,EAAgB,KACrB,OACE,gCACG4K,EADH,KACU5K,IADA0I,SAPlB,oDAAuBmB,GAAiB,WAiB5C,uBACEH,OAAO,EACPmB,aAAa,EACbC,IAAKvB,EACLwB,UAAU,EACVC,MAAO,IACPC,OAAQ,MAE0B,UAAnC7B,EAAgB8B,gBACf,gCAIE,cAACpC,EAAD,CACE3E,iBAAkBiF,EAAgB5L,4BAClCmL,MAAO,CAAEsC,OAAQ,OAEnB,wBAAQE,QAAS,kBAAM/B,EAAgBgC,QAAvC,kBACA,wBAAQD,QAAS,kBAAM/B,EAAgBiC,UAAvC,uBAGJ,8BACE,wBACEC,UAAW5J,QAAQoI,GACnBqB,QAAS,kBACP9U,QAAM8C,mBAAmBqH,6BACvBsJ,IAJN,mCAeOyB,MAzXf,WAEEtC,qBAAU,WACR,IAAMuC,EAAa,IAAIC,oBAEvB9P,QAAQ4H,IAAI,CAAEiI,iBACb,IAEH,MAGIzC,mBAAS,IAHb,mBACE2C,EADF,KAEEC,EAFF,KAKA,EAAwC5C,mBAAS,IAAjD,mBAAO7I,EAAP,KAAqB0L,EAArB,KACA,EAAkD7C,mBAAS,IAA3D,mBAAOM,EAAP,KAA0BwC,EAA1B,KACA,EAAoD9C,mBAAS,IAA7D,mBAAO+C,EAAP,KAA2BC,EAA3B,KAEA9C,qBAAU,WACR4C,EACExV,QAAMiD,kBAAkBuI,wBAAwB3B,IAGlD6L,EACE1V,QAAMiD,kBAAkByI,yBAAyB7B,MAElD,CAACA,IAQJ,IAAM8L,EAA4BC,uBAAY,SAAAC,GAC5CzJ,SAAOc,IAAI,iCAAkC,CAC3C2I,oBACAC,kBAAmBD,EAAkBE,uBACrCC,wBAAyBH,EACtBE,uBACAhO,cAGLuN,GAAuC,SAAAW,GAAI,4BACtCA,GADsC,CAEzCJ,SAED,IAGHjD,qBAAU,WACR,IAAMsD,EAAe,WACnB,IAAMC,EACJpW,oCAAkCqW,sBAEpChK,SAAOc,IAAI,mDAAoD,CAC7DiJ,qBAGFb,EAAuCa,IAYzC,OATAd,EAAoC5N,SAAQ,SAAAnB,GAC1CA,EAAW5E,KACTjB,mCAAiCb,cACjCsW,GAGF5P,EAAWM,GAAGnG,mCAAiCd,YAAauW,MAGvD,WACLb,EAAoC5N,SAAQ,SAAAnB,GAC1CA,EAAWU,IACTvG,mCAAiCb,cACjCsW,GAGF5P,EAAWU,IACTvG,mCAAiCd,YACjCuW,SAIL,CAACb,IAEJ,IAAMgB,EAAuBT,uBAAY,WACvC,IAAM7L,EAAc9J,QAAMiM,6BAE1ByJ,EACE,IAAI5V,oCAAkCgK,EAAa,qBAEpD,CAAC4L,IAEJ,OACE,sBAAK/D,UAAU,MAAf,UACE,gCACE,uCACA,sBAAKU,MAAO,CAAE4B,OAAQ,iBAAkBoC,OAAQ,GAAhD,UACE,+CACA,wBAAQxB,QAAS,kBAAMyB,MAAMvW,QAAMmD,0BAAnC,8CAIF,sBAAKmP,MAAO,CAAE4B,OAAQ,iBAAkBoC,OAAQ,GAAhD,UACE,+CACC,CACC,CACEE,KAAM,uCACNC,GAAI,kBACFzW,QACGiD,oBACAuD,MAAK,SAAAqE,GAAO,OAAI0K,EAAgB1K,QAGvC,CACE2L,KAAM,2CACNC,GAAI,kBACFzW,QACGiD,mBAAkB,GAClBuD,MAAK,SAAAqE,GAAO,OAAI0K,EAAgB1K,QAGvC,CACE2L,KAAM,6BACNC,GAAI,kBACFzW,QACG8C,mBAAmB,KAAM,CACxB4T,MAAO,uBAERlQ,KAAKmP,KAEZ,CACEa,KAAM,0CACNC,GAAI,kBACFzW,QACG8C,mBACC,CAAE2B,OAAO,GACT,CACEiS,MAAO,kCAGVlQ,KAAKmP,MAEZzO,KAAI,WAAemL,GAAf,IAAGmE,EAAH,EAAGA,KAAMC,EAAT,EAASA,GAAT,OACJ,8BACE,wBAAQ3B,QAAS2B,EAAjB,SAAsBD,KADdnE,SAKd,gCACGW,EAAkB5M,OAAS,GAC1B,gCACE,qDACC4M,EAAkB9L,KAAI,SAACkE,EAAQiH,GAAT,OACrB,sBAEEC,MAAO,CACL+B,UAAW,OACXH,OAAQ,iBACRyC,SAAU,OACVC,QAAS,EACTzC,gBAAiB9B,EAAM,EAAI,OAAS,QAPxC,UAUGjH,EAAOvJ,KAVV,IAUiBuJ,EAAON,MACtB,wBACEwH,MAAO,CAAEuE,MAAO,SAChB/B,QAAS,WACP9U,QAAM8C,mBACHoH,2BAA2BkB,EAAQ,KAAM,CACxCsL,MAAOtL,EAAON,QAEftE,KAAKmP,IAPZ,uBAVKtD,SA2BZoD,EAAmBrP,OAAS,GAC3B,gCACE,sDACCqP,EAAmBvO,KAAI,SAACkE,EAAQiH,GAAT,OACtB,sBAEEC,MAAO,CACL+B,UAAW,OACXH,OAAQ,iBACRyC,SAAU,OACVC,QAAS,EACTzC,gBAAiB9B,EAAM,EAAI,OAAS,QAPxC,UAUGjH,EAAOvJ,KAVV,IAUiBuJ,EAAON,QATjBuH,SAeb,sBAAKC,MAAO,CAAE4B,OAAQ,iBAAkBoC,OAAQ,GAAhD,UACE,gDACA,wBACExB,QAAS,kBACP9U,QACG+C,cAAc,KAAM,CACnB2T,MAAO,kBAERlQ,KAAKmP,IANZ,mCAWA,wBAAQb,QAAS,kBAAMyB,MAAMvW,QAAMgD,gCAAnC,0DAON,gCACE,uCACA,gCACE,iDACA,wBAAQ8R,QAAS,kBAAMuB,KAAvB,0CAMJ,qBAAK/D,MAAO,CAAEwE,UAAW,kBAAzB,SACGzB,EAAoCnO,KAAI,SAAC6P,EAAS1E,GACjD,OACE,sBAAeC,MAAO,CAAE4B,OAAQ,kBAAhC,UACE,4CAAe6C,EAAQC,cACtBD,EAAQpP,sBAAsBT,KAAI,SAACZ,EAAY+L,GAAb,OACjC,cAACS,EAAD,CAEEC,gBAAiBzM,EACjB0M,kBAAmBA,GAFdX,MAKT,8BACE,wBAAQyC,QAAS,kBAAMiC,EAAQvV,WAA/B,yBAVM6Q,YCnPP4E,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqB3Q,MAAK,YAAkD,IAA/C4Q,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFtK,SAASuK,eAAe,SAM1BX,M","file":"static/js/main.6753aaaf.chunk.js","sourcesContent":["const {\n  EVT_READY,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} = require(\"./_base/_MediaStreamTrackControllerBase\");\nconst AudioMediaStreamTrackController = require(\"./audio/AudioMediaStreamTrackController\");\nconst VideoMediaStreamTrackController = require(\"./video/VideoMediaStreamTrackController\");\nconst MediaStreamTrackControllerFactory = require(\"./MediaStreamTrackControllerFactory\");\nconst utils = require(\"./utils\");\nconst debug = require(\"./debug\");\nconst AudioMediaStreamTrackLevelMonitor = require(\"./audio/AudioMediaStreamTrackLevelMonitor\");\nconst {\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED,\n  EVT_AUDIO_LEVEL_TICK,\n  EVT_AUDIO_ERROR,\n  EVT_AUDIO_ERROR_RECOVERED,\n} = AudioMediaStreamTrackLevelMonitor;\n\nmodule.exports = {\n  AudioMediaStreamTrackController,\n  VideoMediaStreamTrackController,\n  MediaStreamTrackControllerEvents: {\n    EVT_READY,\n    EVT_UPDATED,\n    EVT_DESTROYED,\n  },\n  MediaStreamTrackControllerFactory,\n  utils,\n  debug,\n  AudioMediaStreamTrackLevelMonitor,\n  AudioMediaStreamTrackLevelMonitorEvents: {\n    EVT_DESTROYED,\n    EVT_AVERAGE_AUDIO_LEVEL_CHANGED,\n    EVT_AUDIO_LEVEL_TICK,\n    EVT_AUDIO_ERROR,\n    EVT_AUDIO_ERROR_RECOVERED,\n  },\n};\n","const CommonBase = require(\"./_CommonControllerAndFactoryBase\");\nconst { EVT_UPDATED, EVT_DESTROYED } = CommonBase;\n\n// TODO: Use PhantomCollection instead?\nconst _instances = {};\n\n/**\n * IMPORTANT: This class should not be utilized directly, and instead should be\n * utilized by the AudioMediaStreamTrackController and\n * VideoMediaStreamTrackController extension classes.\n */\nclass MediaStreamTrackControllerBase extends CommonBase {\n  /**\n   * Retrieves currently active MediaStreamTrackController instances.\n   *\n   * @return {MediaStreamTrackController[]}\n   */\n  static getMediaStreamTrackControllerInstances() {\n    return Object.values(_instances);\n  }\n\n  /**\n   * @param {MediaStreamTrack} inputMediaStreamTrack\n   * @param {Object} options?\n   */\n  constructor(inputMediaStreamTrack, options = {}) {\n    if (!(inputMediaStreamTrack instanceof MediaStreamTrack)) {\n      throw new TypeError(\n        \"inputMediaStreamTrack is not of MediaStreamTrack type\"\n      );\n    }\n\n    super(options);\n\n    _instances[this._uuid] = this;\n\n    this._inputMediaStreamTrack = inputMediaStreamTrack;\n\n    // TODO: Dynamically handle w/ passed option\n    // TODO: Should this automatically be cloned, or is that resource wastage?\n    this._outputMediaStreamTrack = inputMediaStreamTrack;\n\n    this._isTrackEnded = false;\n\n    // Destroy instance once track ends\n    (() => {\n      // IMPORTANT: This timeout is set so that _outputMediaStreamTrack can be\n      // overridden by extender's constructor.\n      setTimeout(() => {\n        const _handleTrackEnded = () => {\n          // This check is here to prevent an infinite loop resulting in\n          // Maximum Callstack Error\n          if (!this._isTrackEnded) {\n            this._isTrackEnded = true;\n\n            this.destroy();\n          }\n        };\n\n        this._inputMediaStreamTrack.addEventListener(\n          \"ended\",\n          _handleTrackEnded\n        );\n        this._outputMediaStreamTrack.addEventListener(\n          \"ended\",\n          _handleTrackEnded\n        );\n\n        this.once(EVT_DESTROYED, () => {\n          this._inputMediaStreamTrack.removeEventListener(\n            \"ended\",\n            _handleTrackEnded\n          );\n          this._outputMediaStreamTrack.removeEventListener(\n            \"ended\",\n            _handleTrackEnded\n          );\n        });\n      });\n    })();\n  }\n\n  /**\n   * Retrieves whether the associated input MediaStreamTrack is an audio or\n   * video track.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/kind\n   *\n   * @return {\"audio\" | \"video\"}\n   */\n  getKind() {\n    return this._inputMediaStreamTrack.kind;\n  }\n\n  /**\n   * @return {MediaStreamTrack}\n   */\n  getOutputMediaStreamTrack() {\n    return this._outputMediaStreamTrack;\n  }\n\n  /**\n   * Alias of this.getOutputMediaStreamTrack().\n   *\n   * @return {MediaStreamTrack}\n   */\n  getOutputTrack() {\n    return this._outputMediaStreamTrack;\n  }\n\n  /**\n   * @return {\"audio\" | \"video\"}\n   */\n  getTrackKind() {\n    return this._outputMediaStreamTrack.kind;\n  }\n\n  /**\n   * Retrieves the settings related to the input MediaStreamTrack.\n   *\n   * @return {MediaTrackSettings}\n   */\n  getInputSettings() {\n    return this._inputMediaStreamTrack.getSettings();\n  }\n\n  /**\n   * Retrieves the settings related to the output MediaStreamTrack (does not\n   * reflect the device the track is rendered on or listened to).\n   *\n   * @return {MediaTrackSettings}\n   */\n  getOutputSettings() {\n    return this._outputMediaStreamTrack.getSettings();\n  }\n\n  /**\n   * Retrieves the input device ID, which is an origin-unique string\n   * identifying the source of the track.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMString\n   *\n   * @return {DOMString}\n   */\n  getInputDeviceId() {\n    const inputSettings = this.getInputSettings();\n\n    if (inputSettings) {\n      return inputSettings.deviceId;\n    }\n  }\n\n  /**\n   * Retrieves an object with a structure based on a subset of MediaDeviceInfo\n   * used for potential device matching with utils.getMediaDeviceMatch().\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo\n   *\n   * @return {Object}\n   */\n  getPartialMediaDeviceInfo() {\n    return {\n      deviceId: this.getInputDeviceId(),\n    };\n  }\n\n  /**\n   * Retrieves MediaDeviceInfo of the track controller, compared against given\n   * array of MediaDeviceInfo descriptions.\n   *\n   * This is written like this because this controller does may not have direct\n   * access to the known list of MediaDeviceInfo as obtained from the window\n   * navigator, and it shouldn't aggressively try to obtain the list (i.e. start\n   * a media device on its own to get the full labels).\n   *\n   * Other considerations include being able to match against remote lists.\n   *\n   * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n   * @return {MediaDeviceInfo | Object}\n   */\n  getInputMediaDeviceInfoFromList(mediaDeviceInfoList) {\n    // FIXME: This require is included within the function body itself because\n    // of a conflict when trying to use it in the outer-scope and trying to\n    // instantiate the class.\n    //\n    // Fixes Uncaught TypeError: Class extends value #<Object> is not a\n    // constructor or null\n    const utils = require(\"../utils\");\n    const { getMatchedMediaDevice } = utils;\n\n    const partialMediaDeviceInfo = this.getPartialMediaDeviceInfo();\n\n    return getMatchedMediaDevice(\n      `${this.getKind()}input`,\n      partialMediaDeviceInfo,\n      mediaDeviceInfoList\n    );\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // Automatically stop input and output tracks\n    this._inputMediaStreamTrack.stop();\n    this._outputMediaStreamTrack.stop();\n\n    // This is needed for any \"ended\" listeners, since we may be stopping the\n    // track programmatically (instead of it ending on its own)\n    this._outputMediaStreamTrack.dispatchEvent(new Event(\"ended\"));\n\n    delete _instances[this._uuid];\n\n    super.destroy();\n  }\n}\n\nmodule.exports = MediaStreamTrackControllerBase;\nmodule.exports.EVT_UPDATED = EVT_UPDATED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","const constraints = require(\"./constraints\");\nconst captureMediaDevice = require(\"./captureMediaDevice\");\nconst captureScreen = require(\"./captureScreen\");\nconst { getIsScreenCaptureSupported } = captureScreen;\nconst fetchMediaDevices = require(\"./fetchMediaDevices\");\nconst {\n  getNewAudioContext,\n  getSharedAudioContext,\n  untilAudioContextResumed,\n} = require(\"./getAudioContext\");\nconst getMatchedMediaDevice = require(\"./getMatchedMediaDevice\");\nconst stopMediaStream = require(\"./stopMediaStream\");\nconst getMediaStreamTrackControllerInstances = require(\"./getMediaStreamTrackControllerInstances\");\n\nmodule.exports = {\n  constraints,\n  captureMediaDevice,\n  captureScreen,\n  getIsScreenCaptureSupported,\n  fetchMediaDevices,\n  getNewAudioContext,\n  getSharedAudioContext,\n  untilAudioContextResumed,\n  getMatchedMediaDevice,\n  stopMediaStream,\n  getMediaStreamTrackControllerInstances,\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"levels\":\"AudioLevelMeter_levels__3RxbJ\",\"level-container\":\"AudioLevelMeter_level-container__2ByOz\",\"level\":\"AudioLevelMeter_level__1tSSz\",\"level-animation\":\"AudioLevelMeter_level-animation__b91Xq\"};","// TODO: While not directly related, this thread might have some useful information regarding constraints to set regarding stereo audio\n// @see https://bugs.chromium.org/p/webrtc/issues/detail?id=8133\n\nconst PhantomCore = require(\"phantom-core\");\n\n/**\n * Deep merges the given user constraints onto the default constraints, where\n * user constraints take precedence.\n *\n * @param {MediaTrackConstraints} defaultConstraints\n * @param {MediaTrackConstraints} userConstraints\n * @return {Object}\n */\nfunction mergeConstraints(defaultConstraints, userConstraints) {\n  return PhantomCore.mergeOptions(defaultConstraints, userConstraints);\n}\n\n/**\n * Given the set of constraints of the given kind (audio or video), normalizes\n * the constraints with the kind as a sub-object and the constraints defined\n * within that sub-object, regardless if the sub-object was part of the\n * supplied constraints.\n *\n * @param {\"audio\" | \"video\"} kind\n * @param {Object | boolean} userConstraints\n * @return {Object}\n */\nfunction createNormalizedConstraintsOfKind(kind, userConstraints = {}) {\n  if (kind !== \"audio\" && kind !== \"video\") {\n    throw new TypeError(\"kind must be either audio or video\");\n  }\n\n  // Implement direct boolean passthru w/ base sub-object\n  if (typeof userConstraints === \"boolean\") {\n    return {\n      [kind]: userConstraints,\n    };\n  }\n\n  // Allow userConstraints to be null\n  if (userConstraints === null || userConstraints === undefined) {\n    userConstraints = {};\n  }\n\n  if (userConstraints[kind] === undefined) {\n    // Migrate existing user constraints to new object\n    const prevUserConstraints = { ...userConstraints };\n\n    userConstraints = {\n      [kind]: prevUserConstraints,\n    };\n  } else if (userConstraints[kind][kind] !== undefined) {\n    // Fix situations where doubled-up kind may be inadvertently passed via\n    // userConstraints\n    userConstraints[kind] = { ...userConstraints[kind][kind] };\n  }\n\n  return userConstraints;\n}\n\n/**\n * @param {MediaTrackConstraints} userConstraints? [default = {}]\n * @return {Object}\n */\nfunction createAudioConstraints(userConstraints = {}) {\n  const DEFAULT_AUDIO_CONSTRAINTS = {\n    audio: {\n      echoCancellation: false,\n      noiseSuppression: false,\n      autoGainControl: false,\n      sampleRate: 48000,\n      sampleSize: 16,\n    },\n  };\n\n  return mergeConstraints(\n    DEFAULT_AUDIO_CONSTRAINTS,\n    createNormalizedConstraintsOfKind(\"audio\", userConstraints)\n  );\n}\n\n/**\n * @param {MediaTrackConstraints} userConstraints? [default = {}]\n * @return {Object}\n */\nfunction createVideoConstraints(userConstraints = {}) {\n  const DEFAULT_VIDEO_CONSTRAINTS = {\n    // TODO: Finish adding\n    video: {},\n  };\n\n  return mergeConstraints(\n    DEFAULT_VIDEO_CONSTRAINTS,\n    createNormalizedConstraintsOfKind(\"video\", userConstraints)\n  );\n}\n\n/**\n * @param {MediaTrackConstraints} userConstraints? [default = {}]\n * @return {Object}\n */\nfunction createScreenCaptureConstraints(userConstraints = {}) {\n  DEFAULT_CONSTRAINTS = {\n    // NOTE: Audio capturing is typically only available in Chromium-based\n    // browsers and typically only works for capturing audio in browser tabs.\n    //\n    // Windows can capture full system audio this way, and Mac can be made to\n    // capture full system audio with a third party virtual audio device\n    // driver.\n    //\n    // To enable audio capturing in Chromium-based browsers, the user typically\n    // needs to enable it in the UI dialog presented when initiating the screen\n    // capture, and is sometimes easy to miss.\n    ...createAudioConstraints(userConstraints && userConstraints.audio),\n\n    // NOTE: Video constraints add cursor capturing capability on top of\n    // existing default video constraints, hence why mergeConstraints is used\n    // in the createVideoConstraints argument.\n    ...createVideoConstraints(\n      mergeConstraints(\n        {\n          cursor: \"always\",\n        },\n        userConstraints && userConstraints.video\n      )\n    ),\n  };\n\n  return mergeConstraints(DEFAULT_CONSTRAINTS, userConstraints);\n}\n\n/**\n * Helper method for obtaining constaints to capture from a specific media\n * device with a given device id and type.\n *\n * @param {string} deviceId\n * @param {\"audio\" | \"video\"} deviceType\n * @param {MediaTrackConstraints} userConstraints? [default = {}]\n * @return {Object}\n */\nfunction getSpecificDeviceIdCaptureConstraints(\n  deviceId,\n  deviceType,\n  userConstraints = {}\n) {\n  const AUDIO_DEVICE_TYPE = \"audio\";\n  const VIDEO_DEVICE_TYPE = \"video\";\n\n  if (deviceType !== AUDIO_DEVICE_TYPE && deviceType !== VIDEO_DEVICE_TYPE) {\n    throw new TypeError(\"deviceType must be audio or video\");\n  }\n\n  const OVERRIDE_CONSTRAINTS = {\n    [deviceType]: {\n      deviceId: {\n        exact: deviceId,\n      },\n    },\n    // Prevent device of alternate type from starting (especially prevents mic\n    // from starting when wanting to only capture video)\n    [deviceType === AUDIO_DEVICE_TYPE\n      ? VIDEO_DEVICE_TYPE\n      : AUDIO_DEVICE_TYPE]: false,\n  };\n\n  // Normalize userConstaints to have deviceType first child object\n  userConstraints = createNormalizedConstraintsOfKind(\n    deviceType,\n    userConstraints\n  );\n\n  // Prevent device from being captured if {audio/video: false} is set\n  if (userConstraints[deviceType] === false) {\n    return {};\n  }\n\n  return mergeConstraints(userConstraints, OVERRIDE_CONSTRAINTS);\n}\n\n/**\n * Helper method for obtaining constaints to capture from a specific media\n * device.\n *\n * @param {MediaDeviceInfo} mediaDeviceInfo @see fetchMediaDevices\n * @param {MediaTrackConstraints} userConstraints? [default = {}]\n * @return {Object}\n */\nfunction getSpecificDeviceCaptureConstraints(\n  mediaDeviceInfo,\n  userConstraints = {}\n) {\n  if (!(mediaDeviceInfo instanceof MediaDeviceInfo)) {\n    console.warn(typeof mediaDeviceInfo);\n\n    throw new TypeError(\"mediaDeviceInfo must be of MediaDeviceInfo type\");\n  }\n\n  return getSpecificDeviceIdCaptureConstraints(\n    mediaDeviceInfo.deviceId,\n    mediaDeviceInfo.kind === \"audioinput\" ? \"audio\" : \"video\",\n    userConstraints\n  );\n}\n\nmodule.exports = {\n  mergeConstraints,\n  createNormalizedConstraintsOfKind,\n  createAudioConstraints,\n  createVideoConstraints,\n  createScreenCaptureConstraints,\n  getSpecificDeviceIdCaptureConstraints,\n  getSpecificDeviceCaptureConstraints,\n};\n","const CommonBase = require(\"./_base/_CommonControllerAndFactoryBase\");\nconst { EVT_READY, EVT_UPDATED, EVT_DESTROYED } = CommonBase;\nconst MediaStreamTrackController = require(\"./_base/_MediaStreamTrackControllerBase\");\nconst AudioMediaStreamTrackController = require(\"./audio/AudioMediaStreamTrackController\");\nconst VideoMediaStreamTrackController = require(\"./video/VideoMediaStreamTrackController\");\nconst debounce = require(\"debounce\");\n\n// TODO: Use PhantomCollection instead?\nconst _factoryInstances = {};\n\n/**\n * Factory class which breaks down a given MediaStream into\n * Audio/VideoMediaStreamTrackController constituents.\n */\nclass MediaStreamControllerFactory extends CommonBase {\n  /**\n   * Retrieves currently active MediaStreamTrackController instances.\n   *\n   * @return {MediaStreamTrackController[]}\n   */\n  static getMediaStreamTrackControllerInstances() {\n    return MediaStreamTrackController.getMediaStreamTrackControllerInstances();\n  }\n\n  /**\n   * @return {MediaStreamControllerFactory[]}\n   */\n  static getFactoryInstances() {\n    return Object.values(_factoryInstances);\n  }\n\n  /**\n   * Processes inputMediaStream, converting it into audio and video track\n   * controllers.\n   *\n   * @param {MediaStream} inputMediaStream\n   * @param {Object} factoryOptions? [optional; default = {}] If set, factoryOptions are\n   * passed collectively to track controller constructors\n   * @return {AudioMediaStreamTrackController[] | VideoMediaStreamTrackController[]}\n   */\n  static createTrackControllersFromMediaStream(\n    inputMediaStream,\n    factoryOptions = {}\n  ) {\n    const controllers = [];\n\n    for (const track of inputMediaStream.getTracks()) {\n      switch (track.kind) {\n        case \"audio\":\n          controllers.push(\n            new AudioMediaStreamTrackController(track, factoryOptions)\n          );\n          break;\n\n        case \"video\":\n          controllers.push(\n            new VideoMediaStreamTrackController(track, factoryOptions)\n          );\n          break;\n\n        default:\n          throw new TypeError(`Unknown track kind: ${track.kind}`);\n      }\n    }\n\n    return controllers;\n  }\n\n  /**\n   * @param {MediaStream} inputMediaStream\n   * @param {Object} factoryOptions?\n   */\n  constructor(inputMediaStream, factoryOptions = {}) {\n    if (!(inputMediaStream instanceof MediaStream)) {\n      throw new TypeError(\"inputMediaStream is not of MediaStream type\");\n    }\n\n    const DEFAULT_FACTORY_OPTIONS = {\n      // Async init\n      isReady: false,\n    };\n\n    super(CommonBase.mergeOptions(DEFAULT_FACTORY_OPTIONS, factoryOptions));\n\n    _factoryInstances[this._uuid] = this;\n\n    this._trackControllers =\n      MediaStreamControllerFactory.createTrackControllersFromMediaStream(\n        inputMediaStream,\n        factoryOptions\n      );\n\n    // Handle auto-destruct once track controllers have ended\n    (() => {\n      // The number of active track controllers\n      let lenControllers = this._trackControllers.length;\n\n      let lenInitControllers = 0;\n\n      for (const controller of this._trackControllers) {\n        controller.onceReady().then(() => {\n          ++lenInitControllers;\n\n          if (lenInitControllers === lenControllers) {\n            super._init();\n          }\n        });\n\n        // Propagate EVT_UPDATED from track controllers up to factory\n        //\n        // IMPORTANT! This is debounced due to the fact that multiple track\n        // controllers may update at the same time\n        const handleTrackUpdated = debounce(\n          () => {\n            // Potentially flip this._isMuted flag before calling EVT_UPDATED\n            this._syncTrackControllersMuteState();\n\n            // Propagate EVT_UPDATED event through factory\n            this.emit(EVT_UPDATED);\n          },\n          0,\n          // Run on tail end of debounce\n          false\n        );\n\n        controller.on(EVT_UPDATED, handleTrackUpdated);\n\n        controller.once(EVT_DESTROYED, () => {\n          // Remove controller from factory controllers\n          this._trackControllers = this._trackControllers.filter(\n            test => !Object.is(test, controller)\n          );\n\n          // Emit EVT_UPDATED since we've updated the track controllers count\n          this.emit(EVT_UPDATED);\n\n          controller.off(EVT_UPDATED, handleTrackUpdated);\n\n          // Decrease active track controller count\n          --lenControllers;\n\n          // Automatically destruct once there are no more active track\n          // controllers\n          if (lenControllers === 0) {\n            this.destroy();\n          }\n        });\n      }\n\n      // Automatically destruct if there are no track controllers\n      if (!this._trackControllers.length) {\n        this.destroy();\n      }\n    })();\n\n    // A MediaStream based on the output tracks of the associated track\n    // controllers\n    this._outputMediaStream = new MediaStream([\n      ...this._trackControllers.map(controller =>\n        controller.getOutputMediaStreamTrack()\n      ),\n    ]);\n  }\n\n  /**\n   * Checks the state of all of the associated track controllers and flips the\n   * this._isMuted flag accordingly without calling EVT_UPDATED.\n   *\n   * This is internally called once each track controller is updated.\n   *\n   * @return {void}\n   */\n  _syncTrackControllersMuteState() {\n    const areAllControllersMuted = this._trackControllers.every(controller =>\n      controller.getIsMuted()\n    );\n\n    if (areAllControllersMuted) {\n      this._isMuted = true;\n    } else {\n      const areSomeControllersUnmuted = this._trackControllers.some(\n        controller => !controller.getIsMuted()\n      );\n\n      if (areSomeControllersUnmuted) {\n        this._isMuted = false;\n      }\n    }\n  }\n\n  /**\n   * Mutes all associated track controllers.\n   *\n   * @param {boolean} isMuted\n   * @return {void}\n   */\n  setIsMuted(isMuted) {\n    this._trackControllers.forEach(controller =>\n      controller.setIsMuted(isMuted)\n    );\n\n    return super.setIsMuted();\n  }\n\n  /**\n    @return {AudioMediaStreamTrackController[] | VideoMediaStreamTrackController[]}\n   */\n  getTrackControllers() {\n    return this._trackControllers;\n  }\n\n  /**\n    @return {AudioMediaStreamTrackController[]}\n   */\n  getAudioTrackControllers() {\n    return this.getTrackControllers().filter(\n      controller => controller instanceof AudioMediaStreamTrackController\n    );\n  }\n\n  /**\n    @return {VideoMediaStreamTrackController[]}\n   */\n  getVideoTrackControllers() {\n    return this.getTrackControllers().filter(\n      controller => controller instanceof VideoMediaStreamTrackController\n    );\n  }\n\n  /**\n   * IMPORTANT: This MediaStream should be considered \"read-only\" and if it\n   * should be stopped by a programmatic interaction, either this factory\n   * instance should be destructed or the relevant track controller.\n   *\n   * This MediaStream should automatically go into an ended state once this\n   * factory has been destructed.\n   *\n   * @return {MediaStream}\n   */\n  getOutputMediaStream() {\n    return this._outputMediaStream;\n  }\n\n  /**\n   * Retrieves an array of input device ids, not guaranteed to be unique, for\n   * all of associated track controllers.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMString\n   *\n   * @return {DOMString[]}\n   */\n  getInputDeviceIds() {\n    return this.getTrackControllers().map(controller =>\n      controller.getInputDeviceId()\n    );\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _factoryInstances[this._uuid];\n\n    // Auto-destruct audio / video controllers\n    await Promise.all(\n      this._trackControllers.map(controller => controller.destroy())\n    );\n\n    super.destroy();\n  }\n}\n\nmodule.exports = MediaStreamControllerFactory;\nmodule.exports.EVT_READY = EVT_READY;\nmodule.exports.EVT_UPDATED = EVT_UPDATED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","/**\n * Retrieves a new AudioContext instance.\n *\n * @return {AudioContext}\n */\nconst getNewAudioContext = () => {\n  const AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioCtx = AudioContext ? new AudioContext() : null;\n\n  return audioCtx;\n};\n\n/**\n * Retrieves a memoized shared audio context, or creates a new one and memoizes\n * it for subsequent calls.\n *\n * @return {AudioContext}\n */\nconst getSharedAudioContext = (() => {\n  // Use for caching\n  const sharedAudioCtx = getNewAudioContext();\n\n  /**\n   * Retrieves the shared AudioContext instance, creating it if not already\n   * created.\n   *\n   * @return {AudioContext}\n   */\n  return () => sharedAudioCtx;\n})();\n\n/**\n * Resolves once audio context is resumed, or if it is currently running.\n *\n * @param {AudioContext} audioCtx? [optional; default = null] If not specified,\n * a shared audio context is utilized instead.\n * @return {Promise<void>}\n */\nconst untilAudioContextResumed = async (audioCtx = null) => {\n  if (!audioCtx) {\n    audioCtx = getSharedAudioContext();\n  }\n\n  // Note: This is not documented in https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n  // Found this fix: https://github.com/Tonejs/Tone.js/issues/341#issuecomment-386725880\n  const isRunning = audioCtx.state === \"running\";\n\n  // Due to browsers' autoplay policy, the AudioContext is only active after\n  // the user has interacted with your app, after which the Promise returned\n  // here is resolved.\n  if (!isRunning) {\n    console.debug(\"Trying to resume audio context\");\n\n    await audioCtx.resume();\n\n    console.debug(\"Audio context resumed\");\n  }\n};\n\nmodule.exports.getNewAudioContext = getNewAudioContext;\nmodule.exports.getSharedAudioContext = getSharedAudioContext;\nmodule.exports.untilAudioContextResumed = untilAudioContextResumed;\n","const PhantomCore = require(\"phantom-core\");\nconst { EVT_UPDATED, EVT_DESTROYED } = PhantomCore;\n\n/**\n * Base class which MediaStreamTrackControllerBase and\n * MediaStreamTrackControllerFactory extend.\n */\nclass CommonControllerAndFactoryBase extends PhantomCore {\n  constructor(...args) {\n    super(...args);\n\n    this._isMuted = false;\n  }\n\n  /**\n   * @param {boolean} isMuted\n   * @return {void}\n   */\n  setIsMuted(isMuted) {\n    this._isMuted = isMuted;\n\n    this.emit(EVT_UPDATED);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  getIsMuted() {\n    return this._isMuted;\n  }\n\n  /**\n   * @return {void}\n   */\n  mute() {\n    this.setIsMuted(true);\n  }\n\n  /**\n   * @return {void}\n   */\n  unmute() {\n    this.setIsMuted(false);\n  }\n\n  /**\n   * Sets muting state to alternate state.\n   *\n   * @return {void}\n   */\n  toggleMute() {\n    this.setIsMuted(!this._isMuted);\n  }\n\n  /**\n   * Alias for this.destroy().\n   *\n   * @return {Promise<void>}\n   */\n  async stop() {\n    return this.destroy();\n  }\n}\n\nmodule.exports = CommonControllerAndFactoryBase;\nmodule.exports.EVT_UPDATED = EVT_UPDATED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","const PhantomCore = require(\"phantom-core\");\nconst MediaStreamTrackControllerBase = require(\"../_base/_MediaStreamTrackControllerBase\");\nconst { EVT_UPDATED, EVT_DESTROYED } = MediaStreamTrackControllerBase;\nconst { getSharedAudioContext } = require(\"../utils/getAudioContext\");\n\n// TODO: Add stereo panner\n// https://stackoverflow.com/questions/5123844/change-left-right-balance-on-playing-audio-in-javascript?rq=1\n//    - default pan set to 0 - center\n//    - const stereoNode = new StereoPannerNode(audioContext, { pan: 0 });\n\n/**\n * Utilized for live-manipulation of audio MediaStreamTrack instances.\n */\nclass AudioMediaStreamTrackController extends MediaStreamTrackControllerBase {\n  /**\n   * @param {MediaStreamTrack} inputMediaStreamTrack\n   * @param {Object} options? [default = {}]\n   */\n  constructor(inputMediaStreamTrack, options = {}) {\n    if (inputMediaStreamTrack.kind !== \"audio\") {\n      throw new TypeError(\"inputMediaStreamTrack is not of audio type\");\n    }\n\n    const DEFAULT_OPTIONS = {\n      isReady: false,\n    };\n\n    super(\n      inputMediaStreamTrack,\n      PhantomCore.mergeOptions(DEFAULT_OPTIONS, options)\n    );\n\n    // TODO: Make dynamic w/ passed config\n    this._audioCtx = getSharedAudioContext();\n\n    // The gain level when unmuted\n    this._unmutedGain = 1;\n\n    (async () => {\n      this._src = this._audioCtx.createMediaStreamSource(\n        new MediaStream([inputMediaStreamTrack])\n      );\n\n      this._dst = this._audioCtx.createMediaStreamDestination();\n      this._gainNode = this._audioCtx.createGain();\n\n      this._src.connect(this._gainNode);\n      this._gainNode.connect(this._dst);\n\n      this._outputMediaStream = this._dst.stream;\n      this._outputMediaStreamTrack = this._outputMediaStream.getTracks()[0];\n\n      await super._init();\n    })();\n  }\n\n  /**\n   * @param {boolean} isMuted\n   */\n  setIsMuted(isMuted) {\n    this.setGain(isMuted ? 0 : this._unmutedGain, false);\n\n    super.setIsMuted(isMuted);\n  }\n\n  /**\n   * @param {number} gain A floating point number from 0 - 1.\n   * @param {boolean} isSetUnmutedGain? [default = true] If true, sets the\n   * value for the gain level to be resumed after unmuting.\n   */\n  setGain(gain, isSetUnmutedGain = true) {\n    if (isSetUnmutedGain) {\n      this._unmutedGain = gain;\n    }\n\n    if (!this._isReady) {\n      throw new Error(\"AudioMediaStreamTrackController is not ready\");\n    }\n\n    if (this._gainNode) {\n      this._gainNode.gain.value = gain;\n    }\n\n    this.emit(EVT_UPDATED);\n  }\n\n  /**\n   * A floating point number from 0 - 1.\n   *\n   * @return {number}\n   */\n  getGain() {\n    if (!this._isReady) {\n      throw new Error(\"AudioMediaStreamTrackController is not ready\");\n    }\n\n    return this._gainNode && this._gainNode.gain && this._gainNode.gain.value;\n  }\n}\n\nmodule.exports = AudioMediaStreamTrackController;\nmodule.exports.EVT_UPDATED = EVT_UPDATED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","const MediaStreamTrackControllerBase = require(\"../_base/_MediaStreamTrackControllerBase\");\nconst { EVT_UPDATED, EVT_DESTROYED } = MediaStreamTrackControllerBase;\n\n/**\n * Utilized for live-manipulation of video MediaStreamTrack instances.\n */\nclass VideoMediaStreamTrackController extends MediaStreamTrackControllerBase {\n  /**\n   * @param {MediaStreamTrack} inputMediaStreamTrack\n   * @param {Object} options? [default = {}]\n   */\n  constructor(inputMediaStreamTrack, options = {}) {\n    if (inputMediaStreamTrack.kind !== \"video\") {\n      throw new TypeError(\"inputMediaStreamTrack is not of video type\");\n    }\n\n    super(inputMediaStreamTrack, options);\n  }\n\n  setIsMuted(isMuted) {\n    console.warn(\"video setIsMuted is not currently implemented\");\n\n    // TODO: Implement ability to mute video\n    super.setIsMuted(isMuted);\n  }\n}\n\nmodule.exports = VideoMediaStreamTrackController;\nmodule.exports.EVT_UPDATED = EVT_UPDATED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","const MediaStreamTrackControllerBase = require(\"../_base/_MediaStreamTrackControllerBase\");\nconst MediaStreamTrackControllerFactory = require(\"../MediaStreamTrackControllerFactory\");\n\nconst {\n  mergeConstraints,\n  getSpecificDeviceCaptureConstraints,\n  createAudioConstraints,\n} = require(\"./constraints\");\n\n/**\n * IMPORTANT: At this time, video is not captured by default.\n *\n * @param {MediaTrackConstraints} constraints? [optional; default = {}]\n * @param {Object} factoryOptions? [optional; default = {}]\n * @return {Promise<MediaStreamTrackControllerFactory>}\n */\nasync function captureMediaDevice(constraints = {}, factoryOptions = {}) {\n  const DEFAULT_CONSTRAINTS = {\n    ...createAudioConstraints(constraints && constraints.audio),\n\n    // FIXME: Implement video constraints if video will be captured by default\n    // ...createVideoConstraints(constraints && constraints.video),\n    video: false,\n  };\n\n  const mediaStream = await navigator.mediaDevices.getUserMedia(\n    mergeConstraints(DEFAULT_CONSTRAINTS, constraints)\n  );\n\n  return new MediaStreamTrackControllerFactory(mediaStream, factoryOptions);\n}\n\n/**\n * Captures audio from the specific audio input device with the given\n * mediaDeviceId.\n *\n * @param {MediaDeviceInfo | Object} mediaDeviceInfo The media device info of the device to capture. @see fetchMediaDevices\n * @param {MediaTrackConstraints} constraints? [optional; default = {}]\n * @param {Object} factoryOptions? [optional; default = {}]\n * @return {Promise<MediaStreamTrackControllerFactory>}\n */\nasync function captureSpecificMediaDevice(\n  mediaDeviceInfo,\n  constraints = {},\n  factoryOptions = {}\n) {\n  return captureMediaDevice(\n    getSpecificDeviceCaptureConstraints(mediaDeviceInfo, \"audio\", constraints),\n    factoryOptions\n  );\n}\n\n/**\n * Searches for, and destructs, all track controllers with the given\n * mediaDeviceInfo as the input device.\n *\n * @param {MediaDeviceInfo | Object} mediaDeviceInfo\n * @throws {ReferenceError} Throws if deviceId is not obtainable from\n * mediaDeviceInfo.\n * @return {Promise<void>}\n */\nasync function uncaptureSpecificMediaDevice(mediaDeviceInfo) {\n  const { deviceId } = mediaDeviceInfo;\n\n  if (!deviceId) {\n    throw new ReferenceError(\"Could not obtain deviceId from mediaDeviceInfo\");\n  }\n\n  // Look up all track controllers with this mediaDeviceInfo and stop them\n  return Promise.all(\n    MediaStreamTrackControllerBase.getMediaStreamTrackControllerInstances()\n      .filter(controller => controller.getInputDeviceId() === deviceId)\n      .map(controller => controller.destroy())\n  );\n}\n\n/**\n * Retrieves the associated track controllers for the given media device.\n *\n * @param {MediaDeviceInfo | Object} mediaDeviceInfo\n * @return {MediaStreamTrackControllerBase[]}\n */\nfunction getMediaDeviceTrackControllers(mediaDeviceInfo) {\n  const { deviceId } = mediaDeviceInfo;\n\n  if (!deviceId) {\n    throw new ReferenceError(\"Could not obtain deviceId from mediaDeviceInfo\");\n  }\n\n  return MediaStreamTrackControllerBase.getMediaStreamTrackControllerInstances().filter(\n    controller => controller.getInputDeviceId() === deviceId\n  );\n}\n\n/**\n * Determines if the given media device is being captured.\n *\n * @param {MediaDeviceInfo | Object} mediaDeviceInfo\n * @return {boolean}\n */\nfunction getIsMediaDeviceBeingCaptured(mediaDeviceInfo) {\n  return getMediaDeviceTrackControllers(mediaDeviceInfo).length > 0;\n}\n\n/**\n * Determines if the user device / browser is capable / configured to support\n * media device capturing.\n *\n * @return {boolean}\n */\nfunction getIsMediaDeviceCaptureSupported() {\n  return (\n    navigator &&\n    navigator.mediaDevices &&\n    typeof navigator.mediaDevices.getUserMedia === \"function\"\n  );\n}\n\nmodule.exports = captureMediaDevice;\nmodule.exports.captureSpecificMediaDevice = captureSpecificMediaDevice;\nmodule.exports.uncaptureSpecificMediaDevice = uncaptureSpecificMediaDevice;\nmodule.exports.getMediaDeviceTrackControllers = getMediaDeviceTrackControllers;\nmodule.exports.getIsMediaDeviceBeingCaptured = getIsMediaDeviceBeingCaptured;\nmodule.exports.getIsMediaDeviceCaptureSupported =\n  getIsMediaDeviceCaptureSupported;\n","const MediaStreamTrackControllerFactory = require(\"../MediaStreamTrackControllerFactory\");\n\nconst { createScreenCaptureConstraints } = require(\"./constraints\");\n\n/**\n * @param {MediaTrackConstraints} constraints? [optional; default = {}]\n * @param {Object} factoryOptions? [optional; default = {}]\n * @return {Promise<MediaStreamTrackControllerFactory>}\n */\nasync function captureScreen(constraints = {}, factoryOptions = {}) {\n  const mediaStream = await navigator.mediaDevices.getDisplayMedia(\n    createScreenCaptureConstraints(constraints)\n  );\n\n  return new MediaStreamTrackControllerFactory(mediaStream, factoryOptions);\n}\n\n/**\n * @return {boolean}\n */\nfunction getIsScreenCaptureSupported() {\n  return (\n    navigator &&\n    navigator.mediaDevices &&\n    typeof navigator.mediaDevices.getDisplayMedia === \"function\"\n  );\n}\n\nmodule.exports = captureScreen;\nmodule.exports.getIsScreenCaptureSupported = getIsScreenCaptureSupported;\n","/**\n * Lists all input and output media devices.\n *\n * IMPORTANT: Unlike the underlying call to\n * navigator.mediaDevices.enumerateDevices, this function will resolve the same\n * MediaDeviceInfo instances across subsequent calls (as long as isAggressive\n * is not changed between calls).\n *\n * @param {boolean} isAggressive? [optional; default=true]\n * @return {Promise<MediaDeviceInfo[]>}\n */\nconst fetchMediaDevices = (() => {\n  const cache = {\n    lastIsAggressive: null,\n    lastMediaDevices: [],\n  };\n\n  return async (isAggressive = true) => {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      console.warn(\"enumerateDevices() not supported.\");\n      return [];\n    }\n\n    const fetchDevices = () => navigator.mediaDevices.enumerateDevices();\n\n    let devices = await fetchDevices();\n\n    // If not able to fetch label for all devices...\n    if (isAggressive && devices.some(({ label }) => !label.length)) {\n      // ... temporarily turn on microphone...\n      const tempMediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      //  ... and fetch again\n      devices = await fetchDevices();\n\n      // ... then turn off the mic\n      tempMediaStream.getTracks().forEach(track => track.stop());\n    }\n\n    // If last run isAggressive is the same as the current, use the cacheDiff,\n    // otherwise bust the cache and start over\n    if (cache.lastIsAggressive === isAggressive) {\n      devices = cacheDiffMediaDevices(cache.lastMediaDevices, devices);\n    } else {\n      // Bust the cache and start over\n\n      // Set updated isAggressive\n      cache.lastIsAggressive = isAggressive;\n\n      // Reset device list\n      cache.lastMediaDevices = [];\n    }\n\n    cache.lastMediaDevices = [...devices];\n\n    return devices;\n  };\n})();\n\n/**\n * @param {MediaDeviceInfo[] | Object[]} prevMediaDevices\n * @param {MediaDeviceInfo[] | Object[]} nextMediaDevices\n * @return {MediaDeviceInfo[] | Object[]}\n */\nconst cacheDiffMediaDevices = (prevMediaDevices, nextMediaDevices) => {\n  /**\n   * This will become what is written back to the mediaDevices state.\n   *\n   * This original value represents the current state of mediaDevices with\n   * removed new devices filtered out.\n   *\n   * @type {MediaDeviceList[]}\n   */\n  const next = prevMediaDevices.filter(device =>\n    Boolean(\n      nextMediaDevices.find(predicate => {\n        const isMatch =\n          predicate.kind === device.kind &&\n          predicate.deviceId === device.deviceId;\n\n        return isMatch;\n      })\n    )\n  );\n\n  // Add new media devices to the next array\n  nextMediaDevices.forEach(device => {\n    const isPrevious = Boolean(\n      prevMediaDevices.find(\n        predicate =>\n          predicate.kind === device.kind &&\n          predicate.deviceId === device.deviceId\n      )\n    );\n\n    if (!isPrevious) {\n      next.push(device);\n    }\n  });\n\n  return next;\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * input devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterInputMediaDevices = mediaDeviceInfoList => {\n  return mediaDeviceInfoList.filter(device => device.kind.includes(\"input\"));\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * audio input devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterAudioInputDevices = mediaDeviceInfoList => {\n  return filterInputMediaDevices(mediaDeviceInfoList).filter(device =>\n    device.kind.includes(\"audio\")\n  );\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * video input devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterVideoInputDevices = mediaDeviceInfoList => {\n  return filterInputMediaDevices(mediaDeviceInfoList).filter(device =>\n    device.kind.includes(\"video\")\n  );\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * output devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterOutputMediaDevices = mediaDeviceInfoList => {\n  return mediaDeviceInfoList.filter(device => device.kind.includes(\"output\"));\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * audio output devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterAudioOutputDevices = mediaDeviceInfoList => {\n  return filterOutputMediaDevices(mediaDeviceInfoList).filter(device =>\n    device.kind.includes(\"audio\")\n  );\n};\n\n/**\n * Returns a filtered array of MediaDeviceInfo[-like] structures, representing\n * video output devices only.\n *\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList\n * @return {MediaDeviceInfo | Object}\n */\nconst filterVideoOutputDevices = mediaDeviceInfoList => {\n  return filterOutputMediaDevices(mediaDeviceInfoList).filter(device =>\n    device.kind.includes(\"video\")\n  );\n};\n\nmodule.exports = fetchMediaDevices;\n\nmodule.exports.cacheDiffMediaDevices = cacheDiffMediaDevices;\n\nmodule.exports.filterInputMediaDevices = filterInputMediaDevices;\nmodule.exports.filterAudioInputDevices = filterAudioInputDevices;\nmodule.exports.filterVideoInputDevices = filterVideoInputDevices;\n\nmodule.exports.filterOutputMediaDevices = filterOutputMediaDevices;\nmodule.exports.filterAudioOutputDevices = filterAudioOutputDevices;\nmodule.exports.filterVideoOutputDevices = filterVideoOutputDevices;\n","/**\n * Determines best-guess comparison of the given MediaDeviceInfo[-like] against\n * an array of MediaDeviceInfo[-like] objects.\n *\n * @param {\"audioinput\" | \"videoinput\" | \"audiooutput\" | \"videooutput\"} kind\n * @param {MediaDeviceInfo | Object} mediaDeviceInfo A regular Object may be\n * passed if unable to acquire original MediaDeviceInfo (i.e. from a serialized\n * cache, etc.)\n * @param {MediaDeviceInfo[] | Object[]} mediaDeviceInfoList An array of\n * MediaDeviceInfo[-like] objects to compare against.\n * @return {MediaDeviceInfo | Object | null}\n */\nconst getMatchedMediaDevice = (kind, mediaDeviceInfo, mediaDeviceInfoList) => {\n  const AVAILABLE_KINDS = [\n    \"audioinput\",\n    \"videoinput\",\n    \"audiooutput\",\n    \"videooutput\",\n  ];\n\n  if (!AVAILABLE_KINDS.includes(kind)) {\n    throw new ReferenceError(`Invalid kind \"${kind}\"`);\n  }\n\n  // Compare w/ deviceId match\n  if (mediaDeviceInfo.deviceId) {\n    const matchedDevice = mediaDeviceInfoList.find(\n      device =>\n        kind === device.kind && mediaDeviceInfo.deviceId === device.deviceId\n    );\n\n    if (matchedDevice) {\n      return matchedDevice;\n    }\n  }\n\n  // NOTE: groupId is not currently being matched against because it may return\n  // a different device within the same group\n\n  // Resort to label checking (best-guess scenario)\n  if (mediaDeviceInfo.label) {\n    // Find first matched device based on label\n    const matchedDevice = mediaDeviceInfoList.find(\n      device => kind === device.kind && mediaDeviceInfo.label === device.label\n    );\n\n    if (matchedDevice) {\n      return matchedDevice;\n    }\n  }\n\n  // IMPORTANT: Don't return the first device in the list as a last resort\n  // because it will likely be the wrong data and skew a lot of implementations\n  // of this function\n  return null;\n};\n\n// NOTE: This is left as a non-default export because other methods may follow,\n// one of which may match the filename\nmodule.exports = getMatchedMediaDevice;\n","/**\n * Stops all of the tracks of the given MediaStream, then removes them from the\n * stream.\n *\n * @param {MediaStream} mediaStream\n * @return {void}\n */\nfunction stopMediaStream(mediaStream) {\n  mediaStream.getTracks().forEach(track => {\n    track.stop();\n\n    /**\n     * Because ended is explicitly not fired when you call track.stop()\n     * yourself. It only fires when a track ends for other reasons.\n     *\n     * From the spec:\n     *\n     * Fired when...\n     * The MediaStreamTrack object's source will no longer provide any data,\n     * either because the user revoked the permissions, or because the source\n     * device has been ejected, or because the remote peer permanently stopped\n     * sending data.\n     *\n     * @see https://stackoverflow.com/questions/55953038/why-is-the-ended-event-not-firing-for-this-mediastreamtrack\n     */\n    // track.dispatchEvent(new Event(\"ended\"));\n\n    mediaStream.removeTrack(track);\n  });\n}\n\nmodule.exports = stopMediaStream;\n","const BaseTrackController = require(\"../_base/_MediaStreamTrackControllerBase\");\n\n/**\n * @return {AudioMediaStreamTrackController[] | VideoMediaStreamTrackController[]}\n */\nfunction getMediaStreamTrackControllerInstances() {\n  return BaseTrackController.getMediaStreamTrackControllerInstances();\n}\n\nmodule.exports = getMediaStreamTrackControllerInstances;\n","const createTestAudioMediaStream = require(\"./createTestAudioMediaStream\");\nconst createTestVideoMediaStream = require(\"./createTestVideoMediaStream\");\n\nmodule.exports = {\n  createTestAudioMediaStream,\n  createTestVideoMediaStream,\n};\n","const { getNewAudioContext, stopMediaStream } = require(\"../utils\");\nconst { logger } = require(\"phantom-core\");\n\n/**\n * Returns a MediaStream with a single pulsing, test audio track which\n * automatically ends at the specified duration.\n *\n * @param {number} duration? [default = 5] Number of seconds the pulse should\n * last.\n * @return {MediaStream}\n */\nfunction createTestAudioMediaStream(duration = 5) {\n  const pulseHz = 880;\n  const lfoHz = 30;\n\n  const audioCtx = getNewAudioContext();\n\n  let osc = audioCtx.createOscillator();\n  osc.type = \"sine\";\n  osc.frequency.setValueAtTime(pulseHz, audioCtx.currentTime);\n\n  let amp = audioCtx.createGain();\n  amp.gain.value = 0.0001;\n  amp.gain.setValueAtTime(1, audioCtx.currentTime);\n\n  let lfo = audioCtx.createOscillator();\n  lfo.type = \"square\";\n  lfo.frequency.setValueAtTime(lfoHz, audioCtx.currentTime);\n\n  const streamOutput = audioCtx.createMediaStreamDestination();\n\n  lfo.connect(amp.gain);\n  osc.connect(amp).connect(streamOutput);\n  lfo.start();\n  osc.start();\n  osc.stop(audioCtx.currentTime + duration);\n\n  const mediaStream = streamOutput.stream;\n\n  // Stop the stream once the pulse time ends\n  setTimeout(() => {\n    stopMediaStream(mediaStream);\n\n    logger.log(\"stopped media stream\");\n\n    audioCtx.close().then(() => logger.log(\"audio context closed\"));\n  }, duration * 1000);\n\n  return mediaStream;\n}\n\nmodule.exports = createTestAudioMediaStream;\n","const { stopMediaStream } = require(\"../utils\");\nconst { logger } = require(\"phantom-core\");\n\n/**\n * Returns a MediaStream with a single test video track which automatically\n * ends at the specified duration.\n *\n * @param {number} duration? [default = 5] Number of seconds the pulse should\n * last.\n * @return {MediaStream}\n */\nfunction createTestVideoMediaStream(duration = 5) {\n  const canvas = document.createElement(\"canvas\");\n\n  document.body.appendChild(canvas);\n\n  const mediaStream = canvas.captureStream(25);\n\n  setTimeout(() => {\n    stopMediaStream(mediaStream);\n\n    document.body.removeChild(canvas);\n\n    logger.log(\"stopped media stream\");\n  }, duration * 1000);\n\n  return mediaStream;\n}\n\nmodule.exports = createTestVideoMediaStream;\n","const AudioMediaStreamTrackLevelMonitorProxy = require(\"./AudioMediaStreamTrackLevelMonitorProxy\");\nconst {\n  EVT_DESTROYED,\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED,\n  EVT_AUDIO_LEVEL_TICK,\n  EVT_AUDIO_ERROR,\n  EVT_AUDIO_ERROR_RECOVERED,\n} = AudioMediaStreamTrackLevelMonitorProxy;\n\nmodule.exports = AudioMediaStreamTrackLevelMonitorProxy;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\nmodule.exports.EVT_AVERAGE_AUDIO_LEVEL_CHANGED =\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED;\nmodule.exports.EVT_AUDIO_LEVEL_TICK = EVT_AUDIO_LEVEL_TICK;\nmodule.exports.EVT_AUDIO_ERROR = EVT_AUDIO_ERROR;\nmodule.exports.EVT_AUDIO_ERROR_RECOVERED = EVT_AUDIO_ERROR_RECOVERED;\n","const PhantomCore = require(\"phantom-core\");\nconst { logger } = PhantomCore;\nconst AudioMediaStreamTrackLevelMonitor = require(\"./_AudioMediaStreamTrackLevelMonitor\");\nconst {\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED,\n  EVT_AUDIO_LEVEL_TICK,\n  EVT_AUDIO_ERROR,\n  EVT_AUDIO_ERROR_RECOVERED,\n  EVT_DESTROYED,\n} = AudioMediaStreamTrackLevelMonitor;\n\n/**\n * The underlying audio monitors which are being proxied to, keyed by the\n * respective MediaStreamTrack id.\n *\n * @type {{key: string, value: AudioMediaStreamTrackLevelMonitor}}\n */\nconst _monitorInstances = {};\n\n/**\n * The number of proxies, per MediaStreamTrack id.\n *\n * @type {{key: string, value: number}}\n */\nconst _proxyCounts = {};\n\n/**\n * Exposed proxy for AudioMediaStreamTrackLevelMonitor.\n *\n * This class acts a one-to-many proxy between the monitor and any consumers on\n * top of it.  The goal of this class is to improve efficiency of duplicate\n * monitored MediaStreamTracks so their events can be utilized in more than one\n * place without reading the track multiple times.\n */\nclass AudioMediaStreamTrackLevelMonitorProxy extends PhantomCore {\n  /**\n   * Adds a proxy instance to the audio level monitor.\n   *\n   * If no audio level monitor the proxied MediaStreamTrack is present, it will\n   * create the monitor.\n   *\n   * On proxy destruct, if no remaining proxies for the monitor are present, it\n   * will destroy the audio level monitor.\n   *\n   * @param {AudioMediaStreamTrackLevelMonitorProxy} proxy\n   * @return {void}\n   */\n  static addProxyInstance(proxy) {\n    const mediaStreamTrack = proxy.getMediaStreamTrack();\n\n    let monitor = _monitorInstances[mediaStreamTrack.id];\n\n    if (!monitor) {\n      monitor = new AudioMediaStreamTrackLevelMonitor(mediaStreamTrack);\n\n      // Handle monitor destroy\n      //\n      // Remove all proxies for the given audio level monitor\n      monitor.once(EVT_DESTROYED, () => {\n        const proxies = _proxyCounts[mediaStreamTrack.id];\n\n        if (proxies) {\n          Object.values(proxies).forEach(proxy => proxy && proxy.destroy());\n        }\n      });\n\n      _monitorInstances[mediaStreamTrack.id] = monitor;\n\n      logger.debug(\"Proxied audio monitor created\", monitor);\n    }\n\n    if (!_proxyCounts[mediaStreamTrack.id]) {\n      // Start the count at one proxied instance\n      _proxyCounts[mediaStreamTrack.id] = 1;\n    } else {\n      // Add to the count of proxied instances\n      ++_proxyCounts[mediaStreamTrack.id];\n    }\n\n    /** @type {string[]} */\n    const proxyEvents = [\n      EVT_AVERAGE_AUDIO_LEVEL_CHANGED,\n      EVT_AUDIO_LEVEL_TICK,\n      EVT_AUDIO_ERROR,\n      EVT_AUDIO_ERROR_RECOVERED,\n      EVT_DESTROYED,\n    ];\n\n    // Keyed with event names\n    const proxyHandlers = {};\n\n    proxyEvents.forEach(proxyEvent => {\n      proxyHandlers[proxyEvent] = data => proxy.emit(proxyEvent, data);\n\n      monitor.on(proxyEvent, proxyHandlers[proxyEvent]);\n    });\n\n    // Handle proxy destroy\n    //\n    // If no remaining proxies, destroy the audio level monitor\n    proxy.once(EVT_DESTROYED, async () => {\n      proxyEvents.forEach(proxyEvent =>\n        monitor.off(proxyEvent, proxyHandlers[proxyEvent])\n      );\n\n      // Subtract from the count of proxied instances\n      --_proxyCounts[mediaStreamTrack.id];\n\n      // Destroy the monitor if all proxies are destroyed\n      if (!_proxyCounts[mediaStreamTrack.id]) {\n        delete _monitorInstances[mediaStreamTrack.id];\n        delete _proxyCounts[mediaStreamTrack.id];\n\n        await monitor.destroy();\n\n        logger.debug(\"Proxied audio monitor destroyed\", monitor);\n      }\n    });\n  }\n\n  /**\n   * @param {MediaStreamTrack} mediaStreamTrack\n   */\n  constructor(mediaStreamTrack) {\n    AudioMediaStreamTrackLevelMonitor.validateAudioTrack(mediaStreamTrack);\n\n    super();\n\n    this._mediaStreamTrack = mediaStreamTrack;\n\n    AudioMediaStreamTrackLevelMonitorProxy.addProxyInstance(this);\n  }\n\n  /**\n   * @return {MediaStreamTrack}\n   */\n  getMediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n}\n\nmodule.exports = AudioMediaStreamTrackLevelMonitorProxy;\nmodule.exports.EVT_AVERAGE_AUDIO_LEVEL_CHANGED =\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED;\nmodule.exports.EVT_AUDIO_LEVEL_TICK = EVT_AUDIO_LEVEL_TICK;\nmodule.exports.EVT_AUDIO_ERROR = EVT_AUDIO_ERROR;\nmodule.exports.EVT_AUDIO_ERROR_RECOVERED = EVT_AUDIO_ERROR_RECOVERED;\nmodule.exports.EVT_DESTROYED = EVT_DESTROYED;\n","/**\n * NOTE: This file is intentionally prefixed with an underline because it's not\n * to be exposed directly.\n *\n * Implementations should use the AudioMediaStreamTrackLevelMonitorProxy\n * instead.\n */\n\nconst PhantomCore = require(\"phantom-core\");\nconst { EVT_DESTROYED } = PhantomCore;\nconst { getSharedAudioContext } = require(\"../../utils/getAudioContext\");\n\n// Emits after audio level has changed, with a value from 0 - 10\n/** @exports */\nconst EVT_AVERAGE_AUDIO_LEVEL_CHANGED = \"audio-level-changed\";\n\n/** @exports */\nconst EVT_AUDIO_LEVEL_TICK = \"audio-level-tick\";\n\n/** @exports */\nconst EVT_AUDIO_ERROR = \"audio-error\";\n\n/** @exports */\nconst EVT_AUDIO_ERROR_RECOVERED = \"audio-error-recovered\";\n\n// Number of ms to wait before track silence should raise an error\nconst SILENCE_TO_ERROR_THRESHOLD_TIME = 10000;\n\n// Audio level is changed to this value when muting is specified, regardless\n// whether there is audio in the stream or not\nconst MUTED_AUDIO_LEVEL = -1;\n\nclass AudioMediaStreamTrackLevelMonitor extends PhantomCore {\n  /**\n   * Validates the given MediaStreamTrack, throwing an exception if it is not\n   * of valid type for use here.\n   *\n   * @param {MediaStreamTrack} mediaStreamTrack An audio MediaStreamTrack.\n   * @throws {TypeError}\n   * @return {void}\n   */\n  static validateAudioTrack(mediaStreamTrack) {\n    if (!(mediaStreamTrack instanceof MediaStreamTrack)) {\n      throw new TypeError(\n        \"mediaStreamTrack should be of MediaStreamTrack type\"\n      );\n    }\n\n    if (mediaStreamTrack.kind !== \"audio\") {\n      throw new TypeError(\"mediaStreamTrack is not an audio track\");\n    }\n  }\n\n  /**\n   * @param {MediaStreamTrack} mediaStreamTrack The track from which to monitor\n   * the audio levels. Must be of audio type.\n   */\n  constructor(mediaStreamTrack) {\n    AudioMediaStreamTrackLevelMonitor.validateAudioTrack(mediaStreamTrack);\n\n    super();\n\n    // IMPORTANT: Using a clone of the MediaStreamTrack is necessary because\n    // iOS may not work correctly here if multiple readings are of the same\n    // track\n    this._mediaStreamTrack = mediaStreamTrack.clone();\n\n    // window.setTimeout instance used for silence-to-error detection\n    this._silenceErrorDetectionTimeout = null;\n\n    // Error, if set, of silence\n    this._silenceAudioError = null;\n\n    this._prevAudioLevel = 0;\n\n    // TODO: Document why this is needed\n    this._pollingStartTime = null;\n\n    this._isMuted = false;\n\n    this._analyser = null;\n    this._stream = null;\n    this._source = null;\n\n    // Handle automatic cleanup once track ends\n    mediaStreamTrack.addEventListener(\"ended\", () => {\n      this.destroy();\n    });\n\n    // (Modified from AudioLevelIndicator.tsx in Twilio Video App React demo app)\n    //\n    // Here we re-initialize the AnalyserNode on focus to avoid an issue in Safari\n    // where the analyzers stop functioning when the user switches to a new tab\n    // and switches back to the app.\n    (() => {\n      const _handleFocus = () => {\n        this._initAudioLevelPolling();\n      };\n\n      window.addEventListener(\"focus\", _handleFocus);\n\n      this.once(EVT_DESTROYED, () => {\n        window.removeEventListener(\"focus\", _handleFocus);\n      });\n    })();\n\n    // Start initial polling\n    //\n    // NOTE (jh): Timeout is added as a grace period to smooth over some rapid\n    // lifecycles caused by components mounting / unmounting\n    setTimeout(() => this._initAudioLevelPolling(), 50);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    clearTimeout(this._silenceErrorDetectionTimeout);\n\n    // NOTE: This is a cloned MediaStreamTrack and it does not stop the input\n    // track on its own (nor should it).  This prevents an issue in Google\n    // Chrome (maybe others) where the recording indicator would stay lit after\n    // the source has been stopped.\n    this._mediaStreamTrack.stop();\n\n    // Reset the levels\n    this.emit(EVT_AUDIO_LEVEL_TICK, {\n      rms: 0,\n      log2Rms: 0,\n    });\n\n    await super.destroy();\n  }\n\n  /**\n   * Note: If this is called more than once, it will re-start the polling sequence.\n   *\n   * Derived from Twilio's documentation.\n   * @see https://www.twilio.com/docs/video/build-js-video-application-recommendations-and-best-practices\n   */\n  async _initAudioLevelPolling() {\n    clearTimeout(this._silenceErrorDetectionTimeout);\n\n    // If we're destroyed, there's nothing we can do about it\n    if (this._isDestroyed) {\n      return;\n    }\n\n    this._pollingStartTime = this.getTime();\n\n    const audioContext = getSharedAudioContext();\n\n    // Due to browsers' autoplay policy, the AudioContext is only active after\n    // the user has interacted with your app, after which the Promise returned\n    // here is resolved.\n    await audioContext.resume();\n\n    // This class may have a rapid lifecycle inside of a React component, so\n    // this subsequent check will ensure we're still running and prevent\n    // potential errors\n    if (this.getIsDestroyed()) {\n      return;\n    }\n\n    this._isAudioContextStarted = true;\n    // this.emit(EVT_AUDIO_CONTEXT_STARTED);\n\n    const mediaStreamTrack = this._mediaStreamTrack;\n\n    if (!mediaStreamTrack) {\n      throw new Error(\"Could not obtain MediaStreamTrack\");\n    }\n\n    // Create an analyser to access the raw audio samples from the microphone.\n    if (!this._analyser) {\n      this._analyser = audioContext.createAnalyser();\n      this._analyser.fftSize = 1024;\n      this._analyser.smoothingTimeConstant = 0.5;\n    }\n\n    if (!this._stream) {\n      this._stream = new MediaStream([mediaStreamTrack]);\n    }\n\n    if (!this._source) {\n      // Connect the LocalAudioTrack's media source to the analyser.\n      // Note: Creating a new MediaStream here to avoid having to pass a\n      // MediaStream to this class\n      this._source = audioContext.createMediaStreamSource(this._stream);\n      this._source.connect(this._analyser);\n\n      this.once(EVT_DESTROYED, () => {\n        this._source.disconnect(this._analyser);\n      });\n    }\n\n    const samples = new Uint8Array(this._analyser.frequencyBinCount);\n\n    // Start initial detection\n    this.audioLevelDidChange(0);\n\n    const pollingStartTime = this._pollingStartTime;\n\n    // Start polling for audio level detection\n    this._handlePollTick({\n      pollingStartTime,\n      analyser: this._analyser,\n      samples,\n    });\n  }\n\n  _emitAudioLevelTick({ rms = 0, log2Rms = 0 }) {\n    this.emit(EVT_AUDIO_LEVEL_TICK, {\n      rms,\n      log2Rms,\n    });\n  }\n\n  /**\n   * Handles one tick cycle of audio level polling by capturing the audio\n   * frequency data and then sending it to the audio level checker.\n   *\n   * @param {AudioLevelPollLoopParams}\n   */\n  _handlePollTick({ pollingStartTime, analyser, samples }) {\n    if (this._isDestroyed || pollingStartTime !== this._pollingStartTime) {\n      // this.log.debug(\"Check audio level loop time is ending\");\n\n      return;\n    }\n\n    // Note: For debugging: A way to simulate unintentional silence is to force\n    // this._isMuted to true, while also muting a device's audio. That will\n    // convince the following code into thinking there's unintentional silence.\n\n    if (this._isMuted) {\n      if (this._prevAudioLevel !== MUTED_AUDIO_LEVEL) {\n        this._prevAudioLevel = MUTED_AUDIO_LEVEL;\n\n        this.audioLevelDidChange(MUTED_AUDIO_LEVEL);\n      }\n    } else {\n      analyser.getByteFrequencyData(samples);\n      const rms = this.rootMeanSquare(samples);\n      const log2Rms = rms && Math.log2(rms);\n\n      // Clear any levels\n      this._emitAudioLevelTick({ rms, log2Rms });\n\n      // Audio audioLevel ranges from 0 (silence) to 10 (loudest).\n      let newAudioLevel = Math.ceil(log2Rms); // Our version; shows quieter, emits more often\n      // let newAudioLevel = Math.ceil((10 * log2Rms) / 8); // Twilio version; shows louder\n\n      // TODO: Is this necessary w/ log2Rms?\n      if (newAudioLevel < 0) {\n        newAudioLevel = 0;\n      } else if (newAudioLevel > 10) {\n        newAudioLevel = 10;\n      }\n\n      if (this._prevAudioLevel !== newAudioLevel) {\n        this._prevAudioLevel = newAudioLevel;\n\n        this.audioLevelDidChange(newAudioLevel);\n      }\n    }\n\n    // TODO: Can this utilize window.requestAnimationFrame reliably now that\n    // we're using the event proxy?\n    setTimeout(() => {\n      if (!this.getIsDestroyed()) {\n        this._handlePollTick({\n          pollingStartTime,\n          analyser,\n          samples,\n        });\n      }\n    }, 50);\n  }\n\n  /**\n   * @param {Uint8Array} samples\n   * @return {number}\n   */\n  rootMeanSquare(samples) {\n    const sumSq = samples.reduce((sumSq, sample) => sumSq + sample * sample, 0);\n    return Math.sqrt(sumSq / samples.length);\n  }\n\n  /**\n   * @return {number}\n   */\n  getTime() {\n    return new Date().getTime();\n  }\n\n  /**\n   * Sets whether the audio for this track should be treated as its muted,\n   * regardless if there is audio data available in the monitor.\n   *\n   * @param {boolean}\n   */\n  setIsMuted(isMuted) {\n    if (isMuted === this._isMuted) {\n      // Silently ignore\n      return;\n    }\n\n    this.log(`Setting muted state to ${isMuted ? \"true\" : \"false\"}`);\n\n    this._isMuted = isMuted;\n  }\n\n  /**\n   * Called after audio level has changed.\n   *\n   * @param {number} audioLevel\n   */\n  audioLevelDidChange(audioLevel) {\n    this._audioLevel = audioLevel;\n\n    if (!audioLevel) {\n      this.silenceDidStart();\n    } else {\n      this.silenceDidEnd();\n    }\n\n    this.emit(EVT_AVERAGE_AUDIO_LEVEL_CHANGED, audioLevel);\n  }\n\n  /**\n   * Called after period of silence has started.\n   */\n  silenceDidStart() {\n    clearTimeout(this._silenceErrorDetectionTimeout);\n\n    this._silenceErrorDetectionTimeout = setTimeout(() => {\n      if (this._isDestroyed || this._isMuted) {\n        return;\n      }\n\n      this._silenceAudioError = new Error(\n        \"Unintentional silence grace period over\"\n      );\n\n      // Silently fail\n      this.log.error(this._silenceAudioError.message);\n\n      // Tell interested listeners\n      this.emit(EVT_AUDIO_ERROR, this._silenceAudioError);\n    }, SILENCE_TO_ERROR_THRESHOLD_TIME);\n  }\n\n  /**\n   * Called after period of silence has ended.\n   */\n  silenceDidEnd() {\n    clearTimeout(this._silenceErrorDetectionTimeout);\n\n    // Detect if existing error should be a false-positive\n    if (this._silenceAudioError) {\n      const audioError = this._silenceAudioError;\n\n      this._silenceAudioError = null;\n\n      this.emit(EVT_AUDIO_ERROR_RECOVERED, audioError);\n    }\n  }\n}\n\nmodule.exports = AudioMediaStreamTrackLevelMonitor;\nmodule.exports.EVT_AVERAGE_AUDIO_LEVEL_CHANGED =\n  EVT_AVERAGE_AUDIO_LEVEL_CHANGED;\nmodule.exports.EVT_AUDIO_LEVEL_TICK = EVT_AUDIO_LEVEL_TICK;\nmodule.exports.EVT_AUDIO_ERROR = EVT_AUDIO_ERROR;\nmodule.exports.EVT_AUDIO_ERROR_RECOVERED = EVT_AUDIO_ERROR_RECOVERED;\n","import React, { useMemo } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./AudioLevelMeter.module.css\";\n\n/**\n * Note: This component can render multiple audio levels together as a single unit, side-by-side.\n *\n * @see https://codepen.io/snart1/pen/rRvwwr\n */\nexport default function AudioLevelMeter({\n  className,\n  percent,\n  percents = [],\n  ...rest\n}) {\n  const renderedLevels = useMemo(() => {\n    let renderedLevels = [...percents];\n\n    if (typeof percent !== \"undefined\") {\n      renderedLevels.push(percent);\n    }\n\n    renderedLevels = renderedLevels.map((level) => 100 - level);\n\n    return renderedLevels;\n  }, [percent, percents]);\n\n  return (\n    <div className={classNames(styles[\"levels\"], className)} {...rest}>\n      {renderedLevels.map((percent, idx) => (\n        <div key={idx} className={styles[\"level-container\"]}>\n          <div\n            className={styles[\"level\"]}\n            style={{\n              clipPath: `inset(${percent}% 0 0 0)`,\n              WebkitClipPath: `inset(${percent}% 0 0 0)`,\n            }}\n          ></div>\n        </div>\n      ))}\n    </div>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport AudioLevelMeter from \"./AudioLevelMeter\";\nimport {\n  AudioMediaStreamTrackLevelMonitor,\n  AudioMediaStreamTrackLevelMonitorEvents,\n} from \"../../media-stream-track-controller\";\n\nconst { EVT_AUDIO_LEVEL_TICK } = AudioMediaStreamTrackLevelMonitorEvents;\n\nexport default function AudioMediaStreamTrackLevelMeter({\n  mediaStreamTrack,\n  ...rest\n}) {\n  const [percent, setPercent] = useState(0);\n\n  useEffect(() => {\n    if (mediaStreamTrack) {\n      const mediaStreamMonitor = new AudioMediaStreamTrackLevelMonitor(\n        mediaStreamTrack\n      );\n\n      mediaStreamMonitor.on(EVT_AUDIO_LEVEL_TICK, ({ rms }) => {\n        // FIXME: This is probably not supposed to be RMS, but it's close\n        // enough for prototyping\n        setPercent(rms);\n      });\n\n      return function unmount() {\n        mediaStreamMonitor.destroy();\n      };\n    }\n  }, [mediaStreamTrack]);\n\n  return <AudioLevelMeter percent={percent} {...rest} />;\n}\n","import AudioLevelMeter from \"./AudioLevelMeter\";\nimport AudioMediaStreamTrackLevelMeter from \"./AudioMediaStreamTrackLevelMeter\";\n\nexport default AudioLevelMeter;\nexport { AudioMediaStreamTrackLevelMeter };\n","/**\n * Prototype React application for debugging media-stream-track-controller\n * tools.\n *\n * This tool is intended to be utilized for manual testing and debugging of the\n * media-stream-track-controller library across multiple devices where\n * automated testing is not fully implemented.\n */\n\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport \"./App.css\";\nimport {\n  MediaStreamTrackControllerFactory,\n  MediaStreamTrackControllerEvents,\n  utils,\n  debug,\n} from \"./media-stream-track-controller\";\nimport { AudioMediaStreamTrackLevelMeter } from \"./components/AudioLevelMeter\";\nimport { logger, PhantomCollection } from \"phantom-core\";\n\nfunction App() {\n  // TODO: Remove\n  useEffect(() => {\n    const collection = new PhantomCollection();\n\n    console.log({ collection });\n  }, []);\n\n  const [\n    mediaStreamTrackControllerFactories,\n    setMediaStreamTrackControllerFactories,\n  ] = useState([]);\n\n  const [mediaDevices, setMediaDevices] = useState([]);\n  const [inputMediaDevices, setInputMediaDevices] = useState([]);\n  const [outputMediaDevices, setOutputMediaDevices] = useState([]);\n\n  useEffect(() => {\n    setInputMediaDevices(\n      utils.fetchMediaDevices.filterInputMediaDevices(mediaDevices)\n    );\n\n    setOutputMediaDevices(\n      utils.fetchMediaDevices.filterOutputMediaDevices(mediaDevices)\n    );\n  }, [mediaDevices]);\n\n  /**\n   * Registers controller factory w/ UI component state.\n   *\n   * @param {MediaStreamTrackControllerFactory} controllerFactory\n   * @return {void}\n   */\n  const registerControllerFactory = useCallback(controllerFactory => {\n    logger.log(\"registering controller factory\", {\n      controllerFactory,\n      outputMediaStream: controllerFactory.getOutputMediaStream(),\n      outputMediaStreamTracks: controllerFactory\n        .getOutputMediaStream()\n        .getTracks(),\n    });\n\n    setMediaStreamTrackControllerFactories(prev => [\n      ...prev,\n      controllerFactory,\n    ]);\n  }, []);\n\n  // Sync mediaStreamTrackControllerFactories once a factory has been destroyed\n  useEffect(() => {\n    const handleUpdate = () => {\n      const factoryInstances =\n        MediaStreamTrackControllerFactory.getFactoryInstances();\n\n      logger.log(\"updating registered controller factory instances\", {\n        factoryInstances,\n      });\n\n      setMediaStreamTrackControllerFactories(factoryInstances);\n    };\n\n    mediaStreamTrackControllerFactories.forEach(controller => {\n      controller.once(\n        MediaStreamTrackControllerEvents.EVT_DESTROYED,\n        handleUpdate\n      );\n\n      controller.on(MediaStreamTrackControllerEvents.EVT_UPDATED, handleUpdate);\n    });\n\n    return function unmount() {\n      mediaStreamTrackControllerFactories.forEach(controller => {\n        controller.off(\n          MediaStreamTrackControllerEvents.EVT_DESTROYED,\n          handleUpdate\n        );\n\n        controller.off(\n          MediaStreamTrackControllerEvents.EVT_UPDATED,\n          handleUpdate\n        );\n      });\n    };\n  }, [mediaStreamTrackControllerFactories]);\n\n  const createPulsatingAudio = useCallback(() => {\n    const mediaStream = debug.createTestAudioMediaStream();\n\n    registerControllerFactory(\n      new MediaStreamTrackControllerFactory(mediaStream, \"pulsatingAudio\")\n    );\n  }, [registerControllerFactory]);\n\n  return (\n    <div className=\"App\">\n      <div>\n        <h1>Utils</h1>\n        <div style={{ border: \"1px #ccc solid\", margin: 5 }}>\n          <h2>Audio Context</h2>\n          <button onClick={() => alert(utils.getSharedAudioContext())}>\n            utils.getSharedAudioContext()\n          </button>\n        </div>\n        <div style={{ border: \"1px #ccc solid\", margin: 5 }}>\n          <h2>Media Devices</h2>\n          {[\n            {\n              name: \"utils.fetchMediaDevices [aggressive]\",\n              cb: () =>\n                utils\n                  .fetchMediaDevices()\n                  .then(devices => setMediaDevices(devices)),\n            },\n            //\n            {\n              name: \"utils.fetchMediaDevices [non-aggressive]\",\n              cb: () =>\n                utils\n                  .fetchMediaDevices(false)\n                  .then(devices => setMediaDevices(devices)),\n            },\n            //\n            {\n              name: \"utils.captureMediaDevice()\",\n              cb: () =>\n                utils\n                  .captureMediaDevice(null, {\n                    title: \"captureMediaDevice\",\n                  })\n                  .then(registerControllerFactory),\n            },\n            {\n              name: \"utils.captureMediaDevice() (with video)\",\n              cb: () =>\n                utils\n                  .captureMediaDevice(\n                    { video: true },\n                    {\n                      title: \"captureMediaDevice-with-video\",\n                    }\n                  )\n                  .then(registerControllerFactory),\n            },\n          ].map(({ name, cb }, idx) => (\n            <div key={idx}>\n              <button onClick={cb}>{name}</button>\n            </div>\n          ))}\n        </div>\n        <div>\n          {inputMediaDevices.length > 0 && (\n            <div>\n              <h3>Input Media Devices</h3>\n              {inputMediaDevices.map((device, idx) => (\n                <div\n                  key={idx}\n                  style={{\n                    textAlign: \"left\",\n                    border: \"1px #000 solid\",\n                    overflow: \"auto\",\n                    padding: 8,\n                    backgroundColor: idx % 2 ? \"#ccc\" : \"#fff\",\n                  }}\n                >\n                  {device.kind} {device.label}\n                  <button\n                    style={{ float: \"right\" }}\n                    onClick={() => {\n                      utils.captureMediaDevice\n                        .captureSpecificMediaDevice(device, null, {\n                          title: device.label,\n                        })\n                        .then(registerControllerFactory);\n                    }}\n                  >\n                    Capture\n                  </button>\n                </div>\n              ))}\n            </div>\n          )}\n\n          {outputMediaDevices.length > 0 && (\n            <div>\n              <h3>Output Media Devices</h3>\n              {outputMediaDevices.map((device, idx) => (\n                <div\n                  key={idx}\n                  style={{\n                    textAlign: \"left\",\n                    border: \"1px #000 solid\",\n                    overflow: \"auto\",\n                    padding: 8,\n                    backgroundColor: idx % 2 ? \"#ccc\" : \"#fff\",\n                  }}\n                >\n                  {device.kind} {device.label}\n                </div>\n              ))}\n            </div>\n          )}\n\n          <div style={{ border: \"1px #ccc solid\", margin: 5 }}>\n            <h2>Screen Capture</h2>\n            <button\n              onClick={() =>\n                utils\n                  .captureScreen(null, {\n                    title: \"captureScreen\",\n                  })\n                  .then(registerControllerFactory)\n              }\n            >\n              utils.captureScreen()\n            </button>\n            <button onClick={() => alert(utils.getIsScreenCaptureSupported())}>\n              utils.getIsScreenCaptureSupported()\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div>\n        <h1>Debug</h1>\n        <div>\n          <h2>Pulsating Audio</h2>\n          <button onClick={() => createPulsatingAudio()}>\n            createPulsatingAudio()\n          </button>\n        </div>\n      </div>\n\n      <div style={{ borderTop: \"4px #000 solid\" }}>\n        {mediaStreamTrackControllerFactories.map((factory, idx) => {\n          return (\n            <div key={idx} style={{ border: \"1px #ccc solid\" }}>\n              <div>Factory: {factory.getTitle()}</div>\n              {factory.getTrackControllers().map((controller, idx) => (\n                <MediaElement\n                  key={idx}\n                  trackController={controller}\n                  inputMediaDevices={inputMediaDevices}\n                />\n              ))}\n              <div>\n                <button onClick={() => factory.destroy()}>Destroy</button>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\n/**\n * Renders UI element for monitoring Audio/VideoMediaStreamTrackController\n * state.\n */\nfunction MediaElement({ trackController, inputMediaDevices }) {\n  const [videoEl, setVideoEl] = useState(null);\n\n  useEffect(() => {\n    (async () => {\n      if (trackController && videoEl) {\n        await trackController.onceReady();\n\n        const track = trackController.getOutputMediaStreamTrack();\n\n        if (track) {\n          videoEl.srcObject = new MediaStream([track]);\n\n          videoEl.muted = false;\n          videoEl.play();\n\n          // Force the UI to scroll to the video element\n          videoEl.scrollIntoView();\n        }\n      }\n    })();\n  }, [trackController, videoEl]);\n\n  const inputDeviceId = useMemo(\n    () => trackController.getInputDeviceId(),\n    [trackController]\n  );\n\n  /**\n   * @return {Object | void}\n   */\n  const matchedInputMediaDevice = useMemo(() => {\n    const match =\n      trackController.getInputMediaDeviceInfoFromList(inputMediaDevices);\n\n    if (match) {\n      // TODO: This is used to convert to a regular object so we can iterate\n      // through the keys using Object.entries.  Perhaps there is a better way\n      // of doing this\n      return JSON.parse(JSON.stringify(match));\n    }\n  }, [trackController, inputMediaDevices]);\n\n  useEffect(() => {\n    if (matchedInputMediaDevice) {\n      // TODO: Handle differently\n      console.log({\n        computedTrackControllers:\n          utils.captureMediaDevice.getMediaDeviceTrackControllers(\n            matchedInputMediaDevice\n          ),\n        isCaptured: utils.captureMediaDevice.getIsMediaDeviceBeingCaptured(\n          matchedInputMediaDevice\n        ),\n      });\n    }\n  }, [matchedInputMediaDevice]);\n\n  return (\n    <div style={{ display: \"inline-block\", border: \"1px #000 solid\" }}>\n      <div\n        style={{ backgroundColor: \"#000\", color: \"#fff\", textAlign: \"left\" }}\n      >\n        {!matchedInputMediaDevice ? (\n          <div>Input Device ID: {inputDeviceId || \"N/A\"}</div>\n        ) : (\n          <div>\n            <h3>Matched Input Media Device</h3>\n            {Object.entries(matchedInputMediaDevice).map(\n              ([key, value], idx) => {\n                return (\n                  <div key={idx}>\n                    {key}: {value}\n                  </div>\n                );\n              }\n            )}\n          </div>\n        )}\n      </div>\n\n      <video\n        muted={true}\n        playsInline={true}\n        ref={setVideoEl}\n        controls={true}\n        width={300}\n        height={300}\n      />\n      {trackController.getTrackKind() === \"audio\" && (\n        <div>\n          {\n            // TODO: Implement gain adjustment UI controller\n          }\n          <AudioMediaStreamTrackLevelMeter\n            mediaStreamTrack={trackController.getOutputMediaStreamTrack()}\n            style={{ height: 100 }}\n          />\n          <button onClick={() => trackController.mute()}>Mute</button>\n          <button onClick={() => trackController.unmute()}>Unmute</button>\n        </div>\n      )}\n      <div>\n        <button\n          disabled={!Boolean(matchedInputMediaDevice)}\n          onClick={() =>\n            utils.captureMediaDevice.uncaptureSpecificMediaDevice(\n              matchedInputMediaDevice\n            )\n          }\n        >\n          Uncapture Device\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}